<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.3 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc docmapping="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-quic-transport-latest" category="std">

  <front>
    <title abbrev="QUIC Transport Protocol">QUIC: A UDP-Based Multiplexed and Secure Transport</title>

    <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
      <organization>Google</organization>
      <address>
        <email>jri@google.com</email>
      </address>
    </author>
    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Mozilla</organization>
      <address>
        <email>martin.thomson@gmail.com</email>
      </address>
    </author>

    <date year="2017" month="July"/>

    <area>Transport</area>
    <workgroup>QUIC</workgroup>
    

    <abstract>


<t>This document defines the core of the QUIC transport protocol.  This document
describes connection establishment, packet format, multiplexing and reliability.
Accompanying documents describe the cryptographic handshake and loss detection.</t>



    </abstract>


    <note title="Note to Readers">


<t>Discussion of this draft takes place on the QUIC working group mailing list
(quic@ietf.org), which is archived at
<eref target="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</eref>.</t>

<t>Working Group information can be found at <eref target="https://github.com/quicwg">https://github.com/quicwg</eref>; source
code and issues list for this draft can be found at
<eref target="https://github.com/quicwg/base-drafts/labels/transport">https://github.com/quicwg/base-drafts/labels/transport</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>QUIC is a multiplexed and secure transport protocol that runs on top of UDP.
QUIC aims to provide a flexible set of features that allow it to be a
general-purpose transport for multiple applications.</t>

<t>QUIC implements techniques learned from experience with TCP, SCTP and other
transport protocols.  Using UDP as the substrate, QUIC seeks to be compatible
with legacy clients and middleboxes.  QUIC authenticates all of its headers and
encrypts most of the data it exchanges, including its signaling.  This allows
the protocol to evolve without incurring a dependency on upgrades to
middleboxes.
This document describes the core QUIC protocol, including the conceptual design,
wire format, and mechanisms of the QUIC protocol for connection establishment,
stream multiplexing, stream and connection-level flow control, and data
reliability.</t>

<t>Accompanying documents describe QUIC’s loss detection and congestion control
<xref target="QUIC-RECOVERY"/>, and the use of TLS 1.3 for key negotiation <xref target="QUIC-TLS"/>.</t>

</section>
<section anchor="conventions-and-definitions" title="Conventions and Definitions">

<t>The words “MUST”, “MUST NOT”, “SHOULD”, and “MAY” are used in this document.
It’s not shouting; when they are capitalized, they have the special meaning
defined in <xref target="RFC2119"/>.</t>

<t>Definitions of terms that are used in this document:</t>

<t><list style="hanging">
  <t hangText='Client:'>
  The endpoint initiating a QUIC connection.</t>
  <t hangText='Server:'>
  The endpoint accepting incoming QUIC connections.</t>
  <t hangText='Endpoint:'>
  The client or server end of a connection.</t>
  <t hangText='Stream:'>
  A logical, bi-directional channel of ordered bytes within a QUIC connection.</t>
  <t hangText='Connection:'>
  A conversation between two QUIC endpoints with a single encryption context
that multiplexes streams within it.</t>
  <t hangText='Connection ID:'>
  The identifier for a QUIC connection.</t>
  <t hangText='QUIC packet:'>
  A well-formed UDP payload that can be parsed by a QUIC receiver.  QUIC packet
size in this document refers to the UDP payload size.</t>
</list></t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>Packet and frame diagrams use the format described in <xref target="RFC2360"/> Section 3.1,
with the following additional conventions:</t>

<t><list style="hanging">
  <t hangText='[x]'>
  Indicates that x is optional</t>
  <t hangText='{x}'>
  Indicates that x is encrypted</t>
  <t hangText='x (A)'>
  Indicates that x is A bits long</t>
  <t hangText='x (A/B/C) …'>
  Indicates that x is one of A, B, or C bits long</t>
  <t hangText='x (*) …'>
  Indicates that x is variable-length</t>
</list></t>

</section>
</section>
<section anchor="a-quic-overview" title="A QUIC Overview">

<t>This section briefly describes QUIC’s key mechanisms and benefits.  Key
strengths of QUIC include:</t>

<t><list style="symbols">
  <t>Low-latency connection establishment</t>
  <t>Multiplexing without head-of-line blocking</t>
  <t>Authenticated and encrypted header and payload</t>
  <t>Rich signaling for congestion control and loss recovery</t>
  <t>Stream and connection flow control</t>
  <t>Connection migration and resilience to NAT rebinding</t>
  <t>Version negotiation</t>
</list></t>

<section anchor="low-latency-connection-establishment" title="Low-Latency Connection Establishment">

<t>QUIC relies on a combined cryptographic and transport handshake for
setting up a secure transport connection.  QUIC connections are
expected to commonly use 0-RTT handshakes, meaning that for most QUIC
connections, data can be sent immediately following the client
handshake packet, without waiting for a reply from the server.  QUIC
provides a dedicated stream (Stream ID 0) to be used for performing
the cryptographic handshake and QUIC options negotiation.  The format
of the QUIC options and parameters used during negotiation are
described in this document, but the handshake protocol that runs on
Stream ID 0 is described in the accompanying cryptographic handshake
draft <xref target="QUIC-TLS"/>.</t>

</section>
<section anchor="stream-multiplexing" title="Stream Multiplexing">

<t>When application messages are transported over TCP, independent application
messages can suffer from head-of-line blocking.  When an application multiplexes
many streams atop TCP’s single-bytestream abstraction, a loss of a TCP segment
results in blocking of all subsequent segments until a retransmission arrives,
irrespective of the application streams that are encapsulated in subsequent
segments.  QUIC ensures that lost packets carrying data for an individual stream
only impact that specific stream.  Data received on other streams can continue
to be reassembled and delivered to the application.</t>

</section>
<section anchor="rich-signaling-for-congestion-control-and-loss-recovery" title="Rich Signaling for Congestion Control and Loss Recovery">

<t>QUIC’s packet framing and acknowledgments carry rich information that help both
congestion control and loss recovery in fundamental ways.  Each QUIC packet
carries a new packet number, including those carrying retransmitted data.  This
obviates the need for a separate mechanism to distinguish acknowledgments for
retransmissions from those for original transmissions, avoiding TCP’s
retransmission ambiguity problem.  QUIC acknowledgments also explicitly encode
the delay between the receipt of a packet and its acknowledgment being sent, and
together with the monotonically-increasing packet numbers, this allows for
precise network roundtrip-time (RTT) calculation.  QUIC’s ACK frames support up
to 256 ACK blocks, so QUIC is more resilient to reordering than TCP with SACK
support, as well as able to keep more bytes on the wire when there is reordering
or loss.</t>

</section>
<section anchor="stream-and-connection-flow-control" title="Stream and Connection Flow Control">

<t>QUIC implements stream- and connection-level flow control.  At a high level, a
QUIC receiver advertises the maximum amount of data that it is willing to
receive on each stream.  As data is sent, received, and delivered on a
particular stream, the receiver sends MAX_STREAM_DATA frames that increase the
advertised limit for that stream, allowing the peer to send more data on that
stream.</t>

<t>In addition to this stream-level flow control, QUIC implements connection-level
flow control to limit the aggregate buffer that a QUIC receiver is willing to
allocate to all streams on a connection.  Connection-level flow control works in
the same way as stream-level flow control, but the bytes delivered and the
limits are aggregated across all streams.</t>

</section>
<section anchor="authenticated-and-encrypted-header-and-payload" title="Authenticated and Encrypted Header and Payload">

<t>TCP headers appear in plaintext on the wire and are not authenticated, causing a
plethora of injection and header manipulation issues for TCP, such as
receive-window manipulation and sequence-number overwriting.  While some of
these are mechanisms used by middleboxes to improve TCP performance, others are
active attacks.  Even “performance-enhancing” middleboxes that routinely
interpose on the transport state machine end up limiting the evolvability of the
transport protocol, as has been observed in the design of MPTCP <xref target="RFC6824"/> and
in its subsequent deployability issues.</t>

<t>Generally, QUIC packets are always authenticated and the payload is typically
fully encrypted.  The parts of the packet header which are not encrypted are
still authenticated by the receiver, so as to thwart any packet injection or
manipulation by third parties.  Some early handshake packets, such as the
Version Negotiation packet, are not encrypted, but information sent in these
unencrypted handshake packets is later verified as part of cryptographic
processing.</t>

<t>PUBLIC_RESET packets that reset a connection are currently not authenticated.</t>

</section>
<section anchor="connection-migration-and-resilience-to-nat-rebinding" title="Connection Migration and Resilience to NAT Rebinding">

<t>QUIC connections are identified by a 64-bit Connection ID, randomly generated by
the server.  QUIC’s consistent connection ID allows connections to survive
changes to the client’s IP and port, such as those caused by NAT rebindings or
by the client changing network connectivity to a new address.  QUIC provides
automatic cryptographic verification of a rebound client, since the client
continues to use the same session key for encrypting and decrypting packets.
The consistent connection ID can be used to allow migration of the connection to
a new server IP address as well, since the Connection ID remains consistent
across changes in the client’s and the server’s network addresses.</t>

</section>
<section anchor="benefit-version-negotiation" title="Version Negotiation">

<t>QUIC version negotiation allows for multiple versions of the protocol to be
deployed and used concurrently. Version negotiation is described in
<xref target="version-negotiation"/>.</t>

</section>
</section>
<section anchor="versions" title="Versions">

<t>QUIC versions are identified using a 32-bit value.</t>

<t>The version 0x00000000 is reserved to represent an invalid version.  This
version of the specification is identified by the number 0x00000001.</t>

<t>Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as
described in <xref target="QUIC-TLS"/>.</t>

<t>Versions with the most significant 16 bits of the version number cleared are
reserved for use in future IETF consensus documents.</t>

<t>Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing
version negotiation to be exercised.  That is, any version number where the low
four bits of all octets is 1010 (in binary).  A client or server MAY advertise
support for any of these reserved versions.</t>

<t>Reserved version numbers will probably never represent a real protocol; a client
MAY use one of these version numbers with the expectation that the server will
initiate version negotiation; a server MAY advertise support for one of these
versions and can expect that clients ignore the value.</t>

<t>[[RFC editor: please remove the remainder of this section before
publication.]]</t>

<t>The version number for the final version of this specification (0x00000001), is
reserved for the version of the protocol that is published as an RFC.</t>

<t>Version numbers used to identify IETF drafts are created by adding the draft
number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be
identified as 0xff00000D.</t>

<t>Implementors are encouraged to register version numbers of QUIC that they
are using for private experimentation on the
<eref target="https://github.com/quicwg/base-drafts/wiki/QUIC-Versions">github wiki</eref>.</t>

</section>
<section anchor="packet-types-and-formats" title="Packet Types and Formats">

<t>We first describe QUIC’s packet types and their formats, since some are
referenced in subsequent mechanisms.</t>

<t>All numeric values are encoded in network byte order (that is, big-endian) and
all field sizes are in bits.  When discussing individual bits of fields, the
least significant bit is referred to as bit 0.  Hexadecimal notation is used for
describing the value of fields.</t>

<t>Any QUIC packet has either a long or a short header, as indicated by the Header
Form bit. Long headers are expected to be used early in the connection before
version negotiation and establishment of 1-RTT keys, and for public resets.
Short headers are minimal version-specific headers, which can be used after
version negotiation and 1-RTT keys are established.</t>

<section anchor="long-header" title="Long Header">

<figure title="Long Header Format" anchor="fig-long-header"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|1|   Type (7)  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Connection ID (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Packet Number (32)                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Version (32)                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Payload (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>Long headers are used for packets that are sent prior to the completion of
version negotiation and establishment of 1-RTT keys. Once both conditions are
met, a sender SHOULD switch to sending short-form headers. While inefficient,
long headers MAY be used for packets encrypted with 1-RTT keys. The long form
allows for special packets, such as the Version Negotiation and the Public Reset
packets to be represented in this uniform fixed-length packet format. A long
header contains the following fields:</t>

<t><list style="hanging">
  <t hangText='Header Form:'>
  The most significant bit (0x80) of the first octet is set to 1 for long
headers and 0 for short headers.</t>
  <t hangText='Long Packet Type:'>
  The remaining seven bits of first octet of a long packet is the packet type.
This field can indicate one of 128 packet types.  The types specified for this
version are listed in <xref target="long-packet-types"/>.</t>
  <t hangText='Connection ID:'>
  Octets 1 through 8 contain the connection ID. <xref target="connection-id"/> describes the
use of this field in more detail.</t>
  <t hangText='Packet Number:'>
  Octets 9 to 12 contain the packet number.  <xref target="packet-numbers"/> describes the
use of packet numbers.</t>
  <t hangText='Version:'>
  Octets 13 to 16 contain the selected protocol version.  This field indicates
which version of QUIC is in use and determines how the rest of the protocol
fields are interpreted.</t>
  <t hangText='Payload:'>
  Octets from 17 onwards (the rest of QUIC packet) are the payload of the
packet.</t>
</list></t>

<t>The following packet types are defined:</t>

<texttable title="Long Header Packet Types" anchor="long-packet-types">
      <ttcol align='left'>Type</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Section</ttcol>
      <c>01</c>
      <c>Version Negotiation</c>
      <c><xref target="packet-version"/></c>
      <c>02</c>
      <c>Client Initial</c>
      <c><xref target="packet-client-initial"/></c>
      <c>03</c>
      <c>Server Stateless Retry</c>
      <c><xref target="packet-server-stateless"/></c>
      <c>04</c>
      <c>Server Cleartext</c>
      <c><xref target="packet-server-cleartext"/></c>
      <c>05</c>
      <c>Client Cleartext</c>
      <c><xref target="packet-client-cleartext"/></c>
      <c>06</c>
      <c>0-RTT Protected</c>
      <c><xref target="packet-protected"/></c>
      <c>07</c>
      <c>1-RTT Protected (key phase 0)</c>
      <c><xref target="packet-protected"/></c>
      <c>08</c>
      <c>1-RTT Protected (key phase 1)</c>
      <c><xref target="packet-protected"/></c>
      <c>09</c>
      <c>Public Reset</c>
      <c><xref target="packet-public-reset"/></c>
</texttable>

<t>The header form, packet type, connection ID, packet number and version fields of
a long header packet are version-independent. The types of packets defined in
<xref target="long-packet-types"/> are version-specific.  See <xref target="version-specific"/> for
details on how packets from different versions of QUIC are interpreted.</t>

<t>(TODO: Should the list of packet types be version-independent?)</t>

<t>The interpretation of the fields and the payload are specific to a version and
packet type.  Type-specific semantics for this version are described in the
following sections.</t>

</section>
<section anchor="short-header" title="Short Header">

<figure title="Short Header Format" anchor="fig-short-header"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
|0|C|K| Type (5)|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                     [Connection ID (64)]                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Packet Number (8/16/32)                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Protected Payload (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The short header can be used after the version and 1-RTT keys are negotiated.
This header form has the following fields:</t>

<t><list style="hanging">
  <t hangText='Header Form:'>
  The most significant bit (0x80) of the first octet of a packet is the header
form.  This bit is set to 0 for the short header.</t>
  <t hangText='Connection ID Flag:'>
  The second bit (0x40) of the first octet indicates whether the Connection ID
field is present.  If set to 1, then the Connection ID field is present; if
set to 0, the Connection ID field is omitted.</t>
  <t hangText='Key Phase Bit:'>
  The third bit (0x20) of the first octet indicates the key phase, which allows
a recipient of a packet to identify the packet protection keys that are used
to protect the packet.  See <xref target="QUIC-TLS"/> for details.</t>
  <t hangText='Short Packet Type:'>
  The remaining 5 bits of the first octet include one of 32 packet types.
<xref target="short-packet-types"/> lists the types that are defined for short packets.</t>
  <t hangText='Connection ID:'>
  If the Connection ID Flag is set, a connection ID occupies octets 1 through 8
of the packet.  See <xref target="connection-id"/> for more details.</t>
  <t hangText='Packet Number:'>
  The length of the packet number field depends on the packet type.  This field
can be 1, 2 or 4 octets long depending on the short packet type.</t>
  <t hangText='Protected Payload:'>
  Packets with a short header always include a 1-RTT protected payload.</t>
</list></t>

<t>The packet type in a short header currently determines only the size of the
packet number field.  Additional types can be used to signal the presence of
other fields.</t>

<texttable title="Short Header Packet Types" anchor="short-packet-types">
      <ttcol align='left'>Type</ttcol>
      <ttcol align='left'>Packet Number Size</ttcol>
      <c>01</c>
      <c>1 octet</c>
      <c>02</c>
      <c>2 octets</c>
      <c>03</c>
      <c>4 octets</c>
</texttable>

<t>The header form, connection ID flag and connection ID of a short header packet
are version-independent.  The remaining fields are specific to the selected QUIC
version.  See <xref target="version-specific"/> for details on how packets from different
versions of QUIC are interpreted.</t>

</section>
<section anchor="packet-version" title="Version Negotiation Packet">

<t>A Version Negotiation packet has long headers with a type value of 0x01 and is
sent only by servers.  The Version Negotiation packet is a response to a client
packet that contains a version that is not supported by the server.</t>

<t>The packet number, connection ID and version fields echo corresponding values
from the triggering client packet.  This allows clients some assurance that the
server received the packet and that the Version Negotiation packet was not
carried in a packet with a spoofed source address.</t>

<t>The payload of the Version Negotiation packet is a list of 32-bit versions which
the server supports, as shown below.</t>

<figure title="Version Negotiation Packet" anchor="version-negotiation-format"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Supported Version 1 (32)                 ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version 2 (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   [Supported Version N (32)]                ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>See <xref target="version-negotiation"/> for a description of the version negotiation
process.</t>

</section>
<section anchor="cleartext-packet" title="Cleartext Packets">

<t>Cleartext packets are sent during the handshake prior to key negotiation.</t>

<t>All cleartext packets contain the current QUIC version in the version field.</t>

<t>The payload of cleartext packets also includes an integrity check, which is
described in <xref target="QUIC-TLS"/>.</t>

<section anchor="packet-client-initial" title="Client Initial Packet">

<t>The Client Initial packet uses long headers with a type value of 0x02.
It carries the first cryptographic handshake message sent by the client.</t>

<t>The client populates the connection ID field with randomly selected values,
unless it has received a packet from the server.  If the client has received a
packet from the server, the connection ID field uses the value provided by the
server.</t>

<t>The packet number used for Client Initial packets is initialized with a random
value each time the new contents are created for the packet.  Retransmissions of
the packet contents increment the packet number by one, see
(<xref target="packet-numbers"/>).</t>

<t>The payload of a Client Initial packet consists of a STREAM frame (or frames)
for stream 0 containing a cryptographic handshake message, plus any PADDING
frames necessary to ensure that the packet is at least the minimum PMTU size
(see <xref target="packetization"/>).  The stream in this packet always starts at an offset
of 0 (see <xref target="stateless-retry"/>) and the complete cyptographic handshake message
MUST fit in a single packet (see <xref target="handshake"/>).</t>

<t>The client uses the Client Initial Packet type for any packet that contains an
initial cryptographic handshake message.  This includes all cases where a new
packet containing the initial cryptographic message needs to be created, this
includes the packets sent after receiving a Version Negotiation
(<xref target="packet-version"/>) or Server Stateless Retry packet
(<xref target="packet-server-stateless"/>).</t>

</section>
<section anchor="packet-server-stateless" title="Server Stateless Retry Packet">

<t>A Server Stateless Retry packet uses long headers with a type value of 0x03.
It carries cryptographic handshake messages and acknowledgments.  It is used
by a server that wishes to perform a stateless retry (see
<xref target="stateless-retry"/>).</t>

<t>The packet number and connection ID fields echo the corresponding fields from
the triggering client packet.  This allows a client to verify that the server
received its packet.</t>

<t>After receiving a Server Stateless Retry packet, the client uses a new Client
Initial packet containing the next cryptographic handshake message.  The client
retains the state of its cryptographic handshake, but discards all transport
state.  In effect, the next cryptographic handshake message is sent on a new
connection.  The new Client Initial packet is sent in a packet with a newly
randomized packet number and starting at a stream offset of 0.</t>

<t>Continuing the cryptographic handshake is necessary to ensure that an attacker
cannot force a downgrade of any cryptographic parameters.  In addition to
continuing the cryptographic handshake, the client MUST remember the results of
any version negotiation that occurred (see <xref target="version-negotiation"/>).  The client
MAY also retain any observed RTT or congestion state that it has accumulated for
the flow, but other transport state MUST be discarded.</t>

<t>The payload of the Server Stateless Retry packet contains STREAM frames and
could contain PADDING and ACK frames.  A server can only send a single Server
Stateless Retry packet in response to each Client Initial packet that is
receives.</t>

</section>
<section anchor="packet-server-cleartext" title="Server Cleartext Packet">

<t>A Server Cleartext packet uses long headers with a type value of 0x04.  It is
used to carry acknowledgments and cryptographic handshake messages from the
server.</t>

<t>The connection ID field in a Server Cleartext packet contains a connection ID
that is chosen by the server (see <xref target="connection-id"/>).</t>

<t>The first Server Cleartext packet contains a randomized packet number.  This
value is increased for each subsequent packet sent by the server as described in
<xref target="packet-numbers"/>.</t>

<t>The payload of this packet contains STREAM frames and could contain PADDING and
ACK frames.</t>

</section>
<section anchor="packet-client-cleartext" title="Client Cleartext Packet">

<t>A Client Cleartext packet uses long headers with a type value of 0x05, and is
sent when the client has received a Server Cleartext packet from the server.</t>

<t>The connection ID field in a Client Cleartext packet contains a server-selected
connection ID, see <xref target="connection-id"/>.</t>

<t>The Client Cleartext packet includes a packet number that is one higher than the
last Client Initial, 0-RTT Protected or Client Cleartext packet that was sent.
The packet number is incremented for each subsequent packet, see
<xref target="packet-numbers"/>.</t>

<t>The payload of this packet contains STREAM frames and could contain PADDING and
ACK frames.</t>

</section>
</section>
<section anchor="packet-protected" title="Protected Packets">

<t>Packets that are protected with 0-RTT keys are sent with long headers.  Packets
that are protected with 1-RTT keys MAY be sent with long headers.  The different
packet types explicitly indicate the encryption level and therefore the keys
that are used to remove packet protection.</t>

<t>Packets protected with 0-RTT keys use a type value of 0x06.  The connection ID
field for a 0-RTT packet is selected by the client.</t>

<t>The client can send 0-RTT packets after having received a packet from the server
if that packet does not complete the handshake.  Even if the client receives a
different connection ID from the server, it MUST NOT update the connection ID it
uses for 0-RTT packets.  This enables consistent routing for all 0-RTT packets.</t>

<t>Packets protected with 1-RTT keys that use long headers use a type value of 0x07
for key phase 0 and 0x08 for key phase 1; see <xref target="QUIC-TLS"/> for more details on
the use of key phases.  The connection ID field for these packet types MUST
contain the value selected by the server, see <xref target="connection-id"/>.</t>

<t>The version field for protected packets is the current QUIC version.</t>

<t>The packet number field contains a packet number, which increases with each
packet sent, see <xref target="packet-numbers"/> for details.</t>

<t>The payload is protected using authenticated encryption.  <xref target="QUIC-TLS"/> describes
packet protection in detail.  After decryption, the plaintext consists of a
sequence of frames, as described in <xref target="frames"/>.</t>

</section>
<section anchor="packet-public-reset" title="Public Reset Packet">

<t>A Public Reset packet is only sent by servers and is used to abruptly terminate
communications. Public Reset is provided as an option of last resort for a
server that does not have access to the state of a connection.  This is intended
for use by a server that has lost state (for example, through a crash or
outage). A server that wishes to communicate a fatal connection error MUST use a
CONNECTION_CLOSE frame if it has sufficient state to do so.</t>

<t>A Public Reset packet uses long headers with a type value of 0x09.</t>

<t>The connection ID and packet number of fields together contain octets 1 through
12 from the packet that triggered the reset.  For a client that sends a
connection ID on every packet, the Connection ID field is simply an echo of the
client’s Connection ID, and the Packet Number field includes an echo of the
client’s packet number.  Depending on the client’s packet number length it might
also include 0, 2, or 3 additional octets from the protected payload of the
client packet.</t>

<t>The version field contains the current QUIC version.</t>

<t>A Public Reset packet sent by a server indicates that it does not have the
state necessary to continue with a connection.  In this case, the server will
include the fields that prove that it originally participated in the connection
(see <xref target="public-reset-proof"/> for details).</t>

<t>Upon receipt of a Public Reset packet that contains a valid proof, a client MUST
tear down state associated with the connection.  The client MUST then cease
sending packets on the connection and SHOULD discard any subsequent packets that
arrive. A Public Reset that does not contain a valid proof MUST be ignored.</t>

<section anchor="public-reset-proof" title="Public Reset Proof">

<t>TODO: Details to be added.</t>

</section>
</section>
<section anchor="connection-id" title="Connection ID">

<t>QUIC connections are identified by their 64-bit Connection ID.  All long headers
contain a Connection ID.  Short headers indicate the presence of a Connection ID
using the CONNECTION_ID flag.  When present, the Connection ID is in the same
location in all packet headers, making it straightforward for middleboxes, such
as load balancers, to locate and use it.</t>

<t>The client MUST choose a random connection ID and use it in Client Initial
packets (<xref target="packet-client-initial"/>) and 0-RTT packets (<xref target="packet-protected"/>).
If the client has received any packet from the server, it uses the connection ID
it received from the server for all packets other than 0-RTT packets.</t>

<t>When the server receives a Client Initial packet and decides to proceed with the
handshake, it chooses a new value for the connection ID and sends that in a
Server Cleartext packet.  The server MAY choose to use the value that the client
initially selects.</t>

<t>Once the client receives the connection ID that the server has chosen, it uses
this for all subsequent packets that it sends, except for any 0-RTT packets,
which all have the same connection ID.</t>

</section>
<section anchor="packet-numbers" title="Packet Numbers">

<t>The packet number is a 64-bit unsigned number and is used as part of a
cryptographic nonce for packet encryption.  Each endpoint maintains a separate
packet number for sending and receiving.  The packet number for sending MUST
increase by at least one after sending any packet, unless otherwise specified
(see <xref target="initial-packet-number"/>).</t>

<t>A QUIC endpoint MUST NOT reuse a packet number within the same connection (that
is, under the same cryptographic keys).  If the packet number for sending
reaches 2^64 - 1, the sender MUST close the connection by sending a
CONNECTION_CLOSE frame with the error code QUIC_SEQUENCE_NUMBER_LIMIT_REACHED
(connection termination is described in <xref target="termination"/>.)</t>

<t>To reduce the number of bits required to represent the packet number over the
wire, only the least significant bits of the packet number are transmitted over
the wire, up to 32 bits.  The actual packet number for each packet is
reconstructed at the receiver based on the largest packet number received on a
successfully authenticated packet.</t>

<t>A packet number is decoded by finding the packet number value that is closest to
the next expected packet.  The next expected packet is the highest received
packet number plus one.  For example, if the highest successfully authenticated
packet had a packet number of 0xaa82f30e, then a packet containing a 16-bit
value of 0x1f94 will be decoded as 0xaa831f94.</t>

<t>The sender MUST use a packet number size able to represent more than twice as
large a range than the difference between the largest acknowledged packet and
packet number being sent.  A peer receiving the packet will then correctly
decode the packet number, unless the packet is delayed in transit such that it
arrives after many higher-numbered packets have been received.  An endpoint MAY
use a larger packet number size to safeguard against such reordering.</t>

<t>As a result, the size of the packet number encoding is at least one more than
the base 2 logarithm of the number of contiguous unacknowledged packet numbers,
including the new packet.</t>

<t>For example, if an endpoint has received an acknowledgment for packet 0x6afa2f,
sending a packet with a number of 0x6b4264 requires a 16-bit or larger packet
number encoding; whereas a 32-bit packet number is needed to send a packet with
a number of 0x6bc107.</t>

<t>Version Negotiation (<xref target="packet-version"/>), Server Stateless Retry
(<xref target="packet-server-stateless"/>), and Public Reset (<xref target="packet-public-reset"/>)
packets have special rules for populating the packet number field.</t>

<section anchor="initial-packet-number" title="Initial Packet Number">

<t>The initial value for packet number MUST be selected from an uniform random
distribution between 0 and 2^31-1.  That is, the lower 31 bits of the packet
number are randomized.  <xref target="RFC4086"/> provides guidance on the generation of
random values.</t>

<t>The first set of packets sent by an endpoint MUST include the low 32-bits of the
packet number.  Once any packet has been acknowledged, subsequent packets can
use a shorter packet number encoding.</t>

<t>A client that receives a Version Negotiation (<xref target="packet-version"/>) or Server
Stateless Retry packet (<xref target="packet-server-stateless"/>) MUST generate a new initial
packet number.  This ensures that the first transmission attempt for a Client
Initial packet (<xref target="packet-client-initial"/>) always contains a randomized packet
number, but packets that contain retransmissions increment the packet number.</t>

<t>A client MUST NOT generate a new initial packet number if it discards the server
packet.  This might happen if the information the client retransmits its Client
Initial packet.</t>

</section>
</section>
<section anchor="version-specific" title="Handling Packets from Different Versions">

<t>Between different versions the following things are guaranteed to remain
constant:</t>

<t><list style="symbols">
  <t>the location of the header form flag,</t>
  <t>the location of the Connection ID flag in short headers,</t>
  <t>the location and size of the Connection ID field in both header forms,</t>
  <t>the location and size of the Version field in long headers, and</t>
  <t>the location and size of the Packet Number field in long headers.</t>
</list></t>

<t>Implementations MUST assume that an unsupported version uses an unknown packet
format. All other fields MUST be ignored when processing a packet that contains
an unsupported version.</t>

</section>
</section>
<section anchor="frames" title="Frames and Frame Types">

<t>The payload of cleartext packets and the plaintext after decryption of protected
payloads consists of a sequence of frames, as shown in <xref target="packet-frames"/>.</t>

<figure title="Contents of Protected Payload" anchor="packet-frames"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 1 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame 2 (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                               ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Frame N (*)                        ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>Protected payloads MUST contain at least one frame, and MAY contain multiple
frames and multiple frame types.</t>

<t>Frames MUST fit within a single QUIC packet and MUST NOT span a QUIC packet
boundary. Each frame begins with a Frame Type byte, indicating its type,
followed by additional type-dependent fields:</t>

<figure title="Generic Frame Layout" anchor="frame-layout"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Type (8)    |           Type-Dependent Fields (*)         ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>Frame types are listed in <xref target="frame-types"/>. Note that the Frame Type byte in
STREAM and ACK frames is used to carry other frame-specific flags.  For all
other frames, the Frame Type byte simply identifies the frame.  These frames are
explained in more detail as they are referenced later in the document.</t>

<texttable title="Frame Types" anchor="frame-types">
      <ttcol align='left'>Type Value</ttcol>
      <ttcol align='left'>Frame Type Name</ttcol>
      <ttcol align='left'>Definition</ttcol>
      <c>0x00</c>
      <c>PADDING</c>
      <c><xref target="frame-padding"/></c>
      <c>0x01</c>
      <c>RST_STREAM</c>
      <c><xref target="frame-rst-stream"/></c>
      <c>0x02</c>
      <c>CONNECTION_CLOSE</c>
      <c><xref target="frame-connection-close"/></c>
      <c>0x03</c>
      <c>GOAWAY</c>
      <c><xref target="frame-goaway"/></c>
      <c>0x04</c>
      <c>MAX_DATA</c>
      <c><xref target="frame-max-data"/></c>
      <c>0x05</c>
      <c>MAX_STREAM_DATA</c>
      <c><xref target="frame-max-stream-data"/></c>
      <c>0x06</c>
      <c>MAX_STREAM_ID</c>
      <c><xref target="frame-max-stream-id"/></c>
      <c>0x07</c>
      <c>PING</c>
      <c><xref target="frame-ping"/></c>
      <c>0x08</c>
      <c>BLOCKED</c>
      <c><xref target="frame-blocked"/></c>
      <c>0x09</c>
      <c>STREAM_BLOCKED</c>
      <c><xref target="frame-stream-blocked"/></c>
      <c>0x0a</c>
      <c>STREAM_ID_NEEDED</c>
      <c><xref target="frame-stream-id-needed"/></c>
      <c>0x0b</c>
      <c>NEW_CONNECTION_ID</c>
      <c><xref target="frame-new-connection-id"/></c>
      <c>0xa0 - 0xbf</c>
      <c>ACK</c>
      <c><xref target="frame-ack"/></c>
      <c>0xc0 - 0xff</c>
      <c>STREAM</c>
      <c><xref target="frame-stream"/></c>
</texttable>

</section>
<section anchor="life-of-a-connection" title="Life of a Connection">

<t>A QUIC connection is a single conversation between two QUIC endpoints.  QUIC’s
connection establishment intertwines version negotiation with the cryptographic
and transport handshakes to reduce connection establishment latency, as
described in <xref target="handshake"/>.  Once established, a connection may migrate to a
different IP or port at either endpoint, due to NAT rebinding or mobility, as
described in <xref target="migration"/>.  Finally a connection may be terminated by either
endpoint, as described in <xref target="termination"/>.</t>

<section anchor="version-negotiation" title="Version Negotiation">

<t>QUIC’s connection establishment begins with version negotiation, since all
communication between the endpoints, including packet and frame formats, relies
on the two endpoints agreeing on a version.</t>

<t>A QUIC connection begins with a client sending a handshake packet. The details
of the handshake mechanisms are described in <xref target="handshake"/>, but all of the
initial packets sent from the client to the server MUST use the long header
format and MUST specify the version of the protocol being used.</t>

<t>When the server receives a packet from a client with the long header format, it
compares the client’s version to the versions it supports.</t>

<t>If the version selected by the client is not acceptable to the server, the
server discards the incoming packet and responds with a Version Negotiation
packet (<xref target="packet-version"/>).  This includes a list of versions that the server
will accept.</t>

<t>A server sends a Version Negotiation packet for every packet that it receives
with an unacceptable version.  This allows a server to process packets with
unsupported versions without retaining state.  Though either the initial client
packet or the version negotiation packet that is sent in response could be lost,
the client will send new packets until it successfully receives a response.</t>

<t>If the packet contains a version that is acceptable to the server, the server
proceeds with the handshake (<xref target="handshake"/>).  This commits the server to the
version that the client selected.</t>

<t>When the client receives a Version Negotiation packet from the server, it should
select an acceptable protocol version.  If the server lists an acceptable
version, the client selects that version and reattempts to create a connection
using that version.  Though the contents of a packet might not change in
response to version negotiation, a client MUST increase the packet number it
uses on every packet it sends.  Packets MUST continue to use long headers and
MUST include the new negotiated protocol version.</t>

<t>The client MUST use the long header format and include its selected version on
all packets until it has 1-RTT keys and it has received a packet from the server
which is not a Version Negotiation packet.</t>

<t>A client MUST NOT change the version it uses unless it is in response to a
Version Negotiation packet from the server.  Once a client receives a packet
from the server which is not a Version Negotiation packet, it MUST ignore other
Version Negotiation packets on the same connection.  Similarly, a client MUST
ignore a Version Negotiation packet if it has already received and acted on a
Version Negotiation packet.</t>

<t>A client MUST ignore a Version Negotiation packet that lists the client’s chosen
version.</t>

<t>Version negotiation uses unprotected data. The result of the negotiation MUST be
revalidated as part of the cryptographic handshake (see <xref target="version-validation"/>).</t>

<section anchor="using-reserved-versions" title="Using Reserved Versions">

<t>For a server to use a new version in the future, clients must correctly handle
unsupported versions. To help ensure this, a server SHOULD include a reserved
version (see <xref target="versions"/>) while generating a Version Negotiation packet.</t>

<t>The design of version negotiation permits a server to avoid maintaining state
for packets that it rejects in this fashion.  However, when the server generates
a Version Negotiation packet, it cannot randomly generate a reserved version
number. This is because the server is required to include the same value in its
transport parameters (see <xref target="version-validation"/>).  To avoid the selected
version number changing during connection establishment, the reserved version
SHOULD be generated as a function of values that will be available to the server
when later generating its handshake packets.</t>

<t>A pseudorandom function that takes client address information (IP and port) and
the client selected version as input would ensure that there is sufficient
variability in the values that a server uses.</t>

<t>A client MAY send a packet using a reserved version number.  This can be used to
solicit a list of supported versions from a server.</t>

</section>
</section>
<section anchor="handshake" title="Cryptographic and Transport Handshake">

<t>QUIC relies on a combined cryptographic and transport handshake to minimize
connection establishment latency.  QUIC allocates stream 0 for the cryptographic
handshake.  Version 0x00000001 of QUIC uses TLS 1.3 as described in
<xref target="QUIC-TLS"/>; a different QUIC version number could indicate that a different
cryptographic handshake protocol is in use.</t>

<t>QUIC provides this stream with reliable, ordered delivery of data.  In return,
the cryptographic handshake provides QUIC with:</t>

<t><list style="symbols">
  <t>authenticated key exchange, where  <list style="symbols">
      <t>a server is always authenticated,</t>
      <t>a client is optionally authenticated,</t>
      <t>every connection produces distinct and unrelated keys,</t>
      <t>keying material is usable for packet protection for both 0-RTT and 1-RTT
packets, and</t>
      <t>1-RTT keys have forward secrecy</t>
    </list></t>
  <t>authenticated values for the transport parameters of the peer (see
<xref target="transport-parameters"/>)</t>
  <t>authenticated confirmation of version negotiation (see <xref target="version-validation"/>)</t>
  <t>authenticated negotiation of an application protocol (TLS uses ALPN
<xref target="RFC7301"/> for this purpose)</t>
  <t>for the server, the ability to carry data that provides assurance that the
client can receive packets that are addressed with the transport address that
is claimed by the client (see <xref target="address-validation"/>)</t>
</list></t>

<t>The initial cryptographic handshake message MUST be sent in a single packet.
Any second attempt that is triggered by address validation MUST also be sent
within a single packet.  This avoids having to reassemble a message from
multiple packets.  Reassembling messages requires that a server maintain state
prior to establishing a connection, exposing the server to a denial of service
risk.</t>

<t>The first client packet of the cryptographic handshake protocol MUST fit within
a 1232 octet QUIC packet payload.  This includes overheads that reduce the space
available to the cryptographic handshake protocol.</t>

<t>Details of how TLS is integrated with QUIC is provided in more detail in
<xref target="QUIC-TLS"/>.</t>

</section>
<section anchor="transport-parameters" title="Transport Parameters">

<t>During connection establishment, both endpoints make authenticated declarations
of their transport parameters.  These declarations are made unilaterally by each
endpoint.  Endpoints are required to comply with the restrictions implied by
these parameters; the description of each parameter includes rules for its
handling.</t>

<t>The format of the transport parameters is the TransportParameters struct from
<xref target="figure-transport-parameters"/>.  This is described using the presentation
language from Section 3 of <xref target="I-D.ietf-tls-tls13"/>.</t>

<figure title="Definition of TransportParameters" anchor="figure-transport-parameters"><artwork><![CDATA[
   uint32 QuicVersion;

   enum {
      initial_max_stream_data(0),
      initial_max_data(1),
      initial_max_stream_id(2),
      idle_timeout(3),
      truncate_connection_id(4),
      max_packet_size(5),
      (65535)
   } TransportParameterId;

   struct {
      TransportParameterId parameter;
      opaque value<0..2^16-1>;
   } TransportParameter;

   struct {
      select (Handshake.msg_type) {
         case client_hello:
            QuicVersion negotiated_version;
            QuicVersion initial_version;

         case encrypted_extensions:
            QuicVersion supported_versions<2..2^8-4>;
      };
      TransportParameter parameters<30..2^16-1>;
   } TransportParameters;
]]></artwork></figure>

<t>The <spanx style="verb">extension_data</spanx> field of the quic_transport_parameters extension defined in
<xref target="QUIC-TLS"/> contains a TransportParameters value.  TLS encoding rules are
therefore used to encode the transport parameters.</t>

<t>QUIC encodes transport parameters into a sequence of octets, which are then
included in the cryptographic handshake.  Once the handshake completes, the
transport parameters declared by the peer are available.  Each endpoint
validates the value provided by its peer.  In particular, version negotiation
MUST be validated (see <xref target="version-validation"/>) before the connection
establishment is considered properly complete.</t>

<t>Definitions for each of the defined transport parameters are included in
<xref target="transport-parameter-definitions"/>.</t>

<section anchor="transport-parameter-definitions" title="Transport Parameter Definitions">

<t>An endpoint MUST include the following parameters in its encoded
TransportParameters:</t>

<t><list style="hanging">
  <t hangText='initial_max_stream_data (0x0000):'>
  The initial stream maximum data parameter contains the initial value for the
maximum data that can be sent on any newly created stream.  This parameter is
encoded as an unsigned 32-bit integer in units of octets.  This is equivalent
to an implicit MAX_STREAM_DATA frame (<xref target="frame-max-stream-data"/>) being sent on
all streams immediately after opening.</t>
  <t hangText='initial_max_data (0x0001):'>
  The initial maximum data parameter contains the initial value for the maximum
amount of data that can be sent on the connection.  This parameter is encoded
as an unsigned 32-bit integer in units of 1024 octets.  That is, the value
here is multiplied by 1024 to determine the actual maximum value.  This is
equivalent to sending a MAX_DATA (<xref target="frame-max-data"/>) for the connection
immediately after completing the handshake.</t>
  <t hangText='initial_max_stream_id (0x0002):'>
  The initial maximum stream ID parameter contains the initial maximum stream
number the peer may initiate, encoded as an unsigned 32-bit integer.  This is
equivalent to sending a MAX_STREAM_ID (<xref target="frame-max-stream-id"/>) immediately
after completing the handshake.</t>
  <t hangText='idle_timeout (0x0003):'>
  The idle timeout is a value in seconds that is encoded as an unsigned 16-bit
integer.  The maximum value is 600 seconds (10 minutes).</t>
</list></t>

<t>An endpoint MAY use the following transport parameters:</t>

<t><list style="hanging">
  <t hangText='truncate_connection_id (0x0004):'>
  The truncated connection identifier parameter indicates that packets sent to
the peer can omit the connection ID.  This can be used by an endpoint where
the 5-tuple is sufficient to identify a connection.  This parameter is zero
length.  Omitting the parameter indicates that the endpoint relies on the
connection ID being present in every packet.</t>
  <t hangText='max_packet_size (0x0005):'>
  The maximum packet size parameter places a limit on the size of packets that
the endpoint is willing to receive, encoded as an unsigned 16-bit integer.
This indicates that packets larger than this limit will be dropped.  The
default for this parameter is the maximum permitted UDP payload of 65527.
Values below 1252 are invalid.  This limit only applies to protected packets
(<xref target="packet-protected"/>).</t>
</list></t>

</section>
<section anchor="zerortt-parameters" title="Values of Transport Parameters for 0-RTT">

<t>Transport parameters from the server MUST be remembered by the client for use
with 0-RTT data.  If the TLS NewSessionTicket message includes the
quic_transport_parameters extension, then those values are used for the server
values when establishing a new connection using that ticket.  Otherwise, the
transport parameters that the server advertises during connection establishment
are used.</t>

<t>A server can remember the transport parameters that it advertised, or store an
integrity-protected copy of the values in the ticket and recover the information
when accepting 0-RTT data.  A server uses the transport parameters in
determining whether to accept 0-RTT data.</t>

<t>A server MAY accept 0-RTT and subsequently provide different values for
transport parameters for use in the new connection.  If 0-RTT data is accepted
by the server, the server MUST NOT reduce any limits or alter any values that
might be violated by the client with its 0-RTT data.  In particular, a server
that accepts 0-RTT data MUST NOT set values for initial_max_data or
initial_max_stream_data that are smaller than the remembered value of those
parameters.  Similarly, a server MUST NOT reduce the value of
initial_max_stream_id.</t>

<t>A server MUST reject 0-RTT data or even abort a handshake if the implied values
for transport parameters cannot be supported.</t>

</section>
<section anchor="new-transport-parameters" title="New Transport Parameters">

<t>New transport parameters can be used to negotiate new protocol behavior.  An
endpoint MUST ignore transport parameters that it does not support.  Absence of
a transport parameter therefore disables any optional protocol feature that is
negotiated using the parameter.</t>

<t>New transport parameters can be registered according to the rules in
<xref target="iana-transport-parameters"/>.</t>

</section>
<section anchor="version-validation" title="Version Negotiation Validation">

<t>The transport parameters include three fields that encode version information.
These retroactively authenticate the version negotiation (see
<xref target="version-negotiation"/>) that is performed prior to the cryptographic handshake.</t>

<t>The cryptographic handshake provides integrity protection for the negotiated
version as part of the transport parameters (see <xref target="transport-parameters"/>).  As
a result, modification of version negotiation packets by an attacker can be
detected.</t>

<t>The client includes two fields in the transport parameters:</t>

<t><list style="symbols">
  <t>The negotiated_version is the version that was finally selected for use.  This
MUST be identical to the value that is on the packet that carries the
ClientHello.  A server that receives a negotiated_version that does not match
the version of QUIC that is in use MUST terminate the connection with a
QUIC_VERSION_NEGOTIATION_MISMATCH error code.</t>
  <t>The initial_version is the version that the client initially attempted to use.
If the server did not send a version negotiation packet <xref target="packet-version"/>,
this will be identical to the negotiated_version.</t>
</list></t>

<t>A server that processes all packets in a stateful fashion can remember how
version negotiation was performed and validate the initial_version value.</t>

<t>A server that does not maintain state for every packet it receives (i.e., a
stateless server) uses a different process. If the initial and negotiated
versions are the same, a stateless server can accept the value.</t>

<t>If the initial version is different from the negotiated_version, a stateless
server MUST check that it would have sent a version negotiation packet if it had
received a packet with the indicated initial_version.  If a server would have
accepted the version included in the initial_version and the value differs from
the value of negotiated_version, the server MUST terminate the connection with a
QUIC_VERSION_NEGOTIATION_MISMATCH error.</t>

<t>The server includes a list of versions that it would send in any version
negotiation packet (<xref target="packet-version"/>) in supported_versions.  This value is
set even if it did not send a version negotiation packet.</t>

<t>The client can validate that the negotiated_version is included in the
supported_versions list and - if version negotiation was performed - that it
would have selected the negotiated version.  A client MUST terminate the
connection with a QUIC_VERSION_NEGOTIATION_MISMATCH error code if the
negotiated_version value is not included in the supported_versions list.  A
client MUST terminate with a QUIC_VERSION_NEGOTIATION_MISMATCH error code if
version negotiation occurred but it would have selected a different version
based on the value of the supported_versions list.</t>

</section>
</section>
<section anchor="stateless-retry" title="Stateless Retries">

<t>A server can process an initial cryptographic handshake messages from a client
without committing any state. This allows a server to perform address validation
(<xref target="address-validation"/>, or to defer connection establishment costs.</t>

<t>A server that generates a response to an initial packet without retaining
connection state MUST use the Server Stateless Retry packet
(<xref target="packet-server-stateless"/>).  This packet causes a client to reset its
transport state and to continue the connection attempt with new connection state
while maintaining the state of the cryptographic handshake.</t>

<t>A server MUST NOT send multiple Server Stateless Retry packets in response to a
client handshake packet.  Thus, any cryptographic handshake message that is sent
MUST fit within a single packet.</t>

<t>In TLS, the Server Stateless Retry packet type is used to carry the
HelloRetryRequest message.</t>

</section>
<section anchor="address-validation" title="Proof of Source Address Ownership">

<t>Transport protocols commonly spend a round trip checking that a client owns the
transport address (IP and port) that it claims.  Verifying that a client can
receive packets sent to its claimed transport address protects against spoofing
of this information by malicious clients.</t>

<t>This technique is used primarily to avoid QUIC from being used for traffic
amplification attack.  In such an attack, a packet is sent to a server with
spoofed source address information that identifies a victim.  If a server
generates more or larger packets in response to that packet, the attacker can
use the server to send more data toward the victim than it would be able to send
on its own.</t>

<t>Several methods are used in QUIC to mitigate this attack.  Firstly, the initial
handshake packet is padded to at least 1280 octets.  This allows a server to
send a similar amount of data without risking causing an amplification attack
toward an unproven remote address.</t>

<t>A server eventually confirms that a client has received its messages when the
cryptographic handshake successfully completes.  This might be insufficient,
either because the server wishes to avoid the computational cost of completing
the handshake, or it might be that the size of the packets that are sent during
the handshake is too large.  This is especially important for 0-RTT, where the
server might wish to provide application data traffic - such as a response to a
request - in response to the data carried in the early data from the client.</t>

<t>To send additional data prior to completing the cryptographic handshake, the
server then needs to validate that the client owns the address that it claims.</t>

<t>Source address validation is therefore performed during the establishment of a
connection.  TLS provides the tools that support the feature, but basic
validation is performed by the core transport protocol.</t>

<section anchor="client-address-validation-procedure" title="Client Address Validation Procedure">

<t>QUIC uses token-based address validation.  Any time the server wishes to
validate a client address, it provides the client with a token.  As long as the
token cannot be easily guessed (see <xref target="token-integrity"/>), if the client is able
to return that token, it proves to the server that it received the token.</t>

<t>During the processing of the cryptographic handshake messages from a client, TLS
will request that QUIC make a decision about whether to proceed based on the
information it has.  TLS will provide QUIC with any token that was provided by
the client.  For an initial packet, QUIC can decide to abort the connection,
allow it to proceed, or request address validation.</t>

<t>If QUIC decides to request address validation, it provides the cryptographic
handshake with a token.  The contents of this token are consumed by the server
that generates the token, so there is no need for a single well-defined format.
A token could include information about the claimed client address (IP and
port), a timestamp, and any other supplementary information the server will need
to validate the token in the future.</t>

<t>The cryptographic handshake is responsible for enacting validation by sending
the address validation token to the client.  A legitimate client will include a
copy of the token when it attempts to continue the handshake.  The cryptographic
handshake extracts the token then asks QUIC a second time whether the token is
acceptable.  In response, QUIC can either abort the connection or permit it to
proceed.</t>

<t>A connection MAY be accepted without address validation - or with only limited
validation - but a server SHOULD limit the data it sends toward an unvalidated
address.  Successful completion of the cryptographic handshake implicitly
provides proof that the client has received packets from the server.</t>

</section>
<section anchor="address-validation-on-session-resumption" title="Address Validation on Session Resumption">

<t>A server MAY provide clients with an address validation token during one
connection that can be used on a subsequent connection.  Address validation is
especially important with 0-RTT because a server potentially sends a significant
amount of data to a client in response to 0-RTT data.</t>

<t>A different type of token is needed when resuming.  Unlike the token that is
created during a handshake, there might be some time between when the token is
created and when the token is subsequently used.  Thus, a resumption token
SHOULD include an expiration time.  It is also unlikely that the client port
number is the same on two different connections; validating the port is
therefore unlikely to be successful.</t>

<t>This token can be provided to the cryptographic handshake immediately after
establishing a connection.  QUIC might also generate an updated token if
significant time passes or the client address changes for any reason (see
<xref target="migration"/>).  The cryptographic handshake is responsible for providing the
client with the token.  In TLS the token is included in the ticket that is used
for resumption and 0-RTT, which is carried in a NewSessionTicket message.</t>

</section>
<section anchor="token-integrity" title="Address Validation Token Integrity">

<t>An address validation token MUST be difficult to guess.  Including a large
enough random value in the token would be sufficient, but this depends on the
server remembering the value it sends to clients.</t>

<t>A token-based scheme allows the server to offload any state associated with
validation to the client.  For this design to work, the token MUST be covered by
integrity protection against modification or falsification by clients.  Without
integrity protection, malicious clients could generate or guess values for
tokens that would be accepted by the server.  Only the server requires access to
the integrity protection key for tokens.</t>

<t>In TLS the address validation token is often bundled with the information that
TLS requires, such as the resumption secret.  In this case, adding integrity
protection can be delegated to the cryptographic handshake protocol, avoiding
redundant protection.  If integrity protection is delegated to the cryptographic
handshake, an integrity failure will result in immediate cryptographic handshake
failure.  If integrity protection is performed by QUIC, QUIC MUST abort the
connection if the integrity check fails with a QUIC_ADDRESS_VALIDATION_FAILURE
error code.</t>

</section>
</section>
<section anchor="migration" title="Connection Migration">

<t>QUIC connections are identified by their 64-bit Connection ID.  QUIC’s
consistent connection ID allows connections to survive changes to the client’s
IP and/or port, such as those caused by client or server migrating to a new
network.  Connection migration allows a client to retain any shared state with a
connection when they move networks.  This includes state that can be hard to
recover such as outstanding requests, which might otherwise be lost with no easy
way to retry them.</t>

<section anchor="migration-linkability" title="Privacy Implications of Connection Migration">

<t>Using a stable connection ID on multiple network paths allows a
passive observer to correlate activity between those paths.  A client
that moves between networks might not wish to have their activity
correlated by any entity other than a server. The NEW_CONNECTION_ID
message can be sent by a server to provide an unlinkable connection ID
for use in case the client wishes to explicitly break linkability
between two points of network attachment.</t>

<t>A client which wishes to break linkability upon changing networks MUST
use the NEW_CONNECTION_ID as well as incrementing the packet sequence
number by an externally unpredictable value computed as described in
<xref target="packet-number-gap"/>. Packet number gaps are cumulative.  A client
might skip connection IDs, but it MUST ensure that it applies the
associated packet number gaps in addition to the packet number gap
associated with the connection ID that it does use.</t>

<t>A client might need to send packets on multiple networks without receiving any
response from the server.  To ensure that the client is not linkable across each
of these changes, a new connection ID and packet number gap are needed for each
network.  To support this, a server sends multiple NEW_CONNECTION_ID messages.
Each NEW_CONNECTION_ID is marked with a sequence number.  Connection IDs MUST be
used in the order in which they are numbered.</t>

<t>A server that receives a packet that is marked with a new connection ID recovers
the packet number by adding the cumulative packet number gap to its expected
packet number.  A server SHOULD discard packets that contain a smaller gap than
it advertised.</t>

<t>For instance, a server might provide a packet number gap of 7 associated with a
new connection ID.  If the server received packet 10 using the previous
connection ID, it should expect packets on the new connection ID to start at 18.
A packet with the new connection ID and a packet number of 17 is discarded as
being in error.</t>

<section anchor="packet-number-gap" title="Packet Number Gap">

<t>In order to avoid linkage, the packet number gap MUST be externally
indistinguishable from random. The packet number gap for a connection
ID with sequence number is computed by encoding the sequence number
as a 32-bit integer in big-endian format, and then computing:</t>

<figure><artwork><![CDATA[
Gap = HKDF-Expand-Label(packet_number_secret,
                        "QUIC packet sequence gap", sequence, 4)
]]></artwork></figure>

<t>The output of HKDF-Expand-Label is interpreted as a big-endian
number. “packet_number_secret” is derived from the TLS key exchange,
as described in <xref target="QUIC-TLS"/> Section 5.6.</t>

</section>
</section>
<section anchor="address-validation-for-migrated-connections" title="Address Validation for Migrated Connections">

<t>TODO: see issue #161</t>

</section>
</section>
<section anchor="termination" title="Connection Termination">

<t>Connections should remain open until they become idle for a pre-negotiated
period of time.  A QUIC connection, once established, can be terminated in one
of three ways:</t>

<t><list style="numbers">
  <t>Explicit Shutdown: An endpoint sends a CONNECTION_CLOSE frame to
initiate a connection termination.  An endpoint may send a GOAWAY frame to
the peer prior to a CONNECTION_CLOSE to indicate that the connection will
soon be terminated.  A GOAWAY frame signals to the peer that any active
streams will continue to be processed, but the sender of the GOAWAY will not
initiate any additional streams and will not accept any new incoming streams.
On termination of the active streams, a CONNECTION_CLOSE may be sent.  If an
endpoint sends a CONNECTION_CLOSE frame while unterminated streams are active
(no FIN bit or RST_STREAM frames have been sent or received for one or more
streams), then the peer must assume that the streams were incomplete and were
abnormally terminated.</t>
  <t>Implicit Shutdown: The default idle timeout is a required parameter in
connection negotiation.  The maximum is 10 minutes.  If there is no network
activity for the duration of the idle timeout, the connection is closed.  By
default a CONNECTION_CLOSE frame will be sent.  A silent close option can be
enabled when it is expensive to send an explicit close, such as mobile
networks that must wake up the radio.</t>
  <t>Abrupt Shutdown: An endpoint may send a Public Reset packet at any time
during the connection to abruptly terminate an active connection.  A Public
Reset packet SHOULD only be used as a final recourse.  Commonly, a public
reset is expected to be sent when a packet on an established connection is
received by an endpoint that is unable decrypt the packet.  For instance, if
a server reboots mid-connection and loses any cryptographic state associated
with open connections, and then receives a packet on an open connection, it
should send a Public Reset packet in return.  (TODO: articulate rules around
when a public reset should be sent.)</t>
</list></t>

<t>TODO: Connections that are terminated are added to a TIME_WAIT list at the
server, so as to absorb any straggler packets in the network.  Discuss TIME_WAIT
list.</t>

</section>
</section>
<section anchor="frame-types-and-formats" title="Frame Types and Formats">

<t>As described in <xref target="frames"/>, Regular packets contain one or more frames.
We now describe the various QUIC frame types that can be present in a Regular
packet. The use of these frames and various frame header bits are described in
subsequent sections.</t>

<section anchor="frame-stream" title="STREAM Frame">

<t>STREAM frames implicitly create a stream and carry stream data. The type byte
for a STREAM frame contains embedded flags, and is formatted as <spanx style="verb">11FSSOOD</spanx>.
These bits are parsed as follows:</t>

<t><list style="symbols">
  <t>The first two bits must be set to 11, indicating that this is a STREAM frame.</t>
  <t><spanx style="verb">F</spanx> is the FIN bit, which is used for stream termination.</t>
  <t>The <spanx style="verb">SS</spanx> bits encode the length of the Stream ID header field.
The values 00, 01, 02, and 03 indicate lengths of 8, 16, 24, and 32 bits
long respectively.</t>
  <t>The <spanx style="verb">OO</spanx> bits encode the length of the Offset header field.
The values 00, 01, 02, and 03 indicate lengths of 0, 16, 32, and
64 bits long respectively.</t>
  <t>The <spanx style="verb">D</spanx> bit indicates whether a Data Length field is present in the STREAM
header.  When set to 0, this field indicates that the Stream Data field
extends to the end of the packet.  When set to 1, this field indicates that
Data Length field contains the length (in bytes) of the Stream Data field.
The option to omit the length should only be used when the packet is a
“full-sized” packet, to avoid the risk of corruption via padding.</t>
</list></t>

<t>A STREAM frame is shown below.</t>

<figure title="STREAM Frame Format" anchor="stream-format"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Stream ID (8/16/24/32)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Offset (0/16/32/64)                    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       [Data Length (16)]      |        Stream Data (*)      ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The STREAM frame contains the following fields:</t>

<t><list style="hanging">
  <t hangText='Stream ID:'>
  The stream ID of the stream (see <xref target="stream-id"/>).</t>
  <t hangText='Offset:'>
  A variable-sized unsigned number specifying the byte offset in the stream for
the data in this STREAM frame.  When the offset length is 0, the offset is 0.
The first byte in the stream has an offset of 0.  The largest offset delivered
on a stream - the sum of the re-constructed offset and data length - MUST be
less than 2^64.</t>
  <t hangText='Data Length:'>
  An optional 16-bit unsigned number specifying the length of the Stream Data
field in this STREAM frame.  This field is present when the <spanx style="verb">D</spanx> bit is set to
1.</t>
  <t hangText='Stream Data:'>
  The bytes from the designated stream to be delivered.</t>
</list></t>

<t>A STREAM frame MUST have either non-zero data length or the FIN bit set.  When
the FIN flag is sent on an empty STREAM frame, the offset in the STREAM frame
MUST be one greater than the last data byte sent on this stream.</t>

<t>Stream multiplexing is achieved by interleaving STREAM frames from multiple
streams into one or more QUIC packets.  A single QUIC packet can include
multiple STREAM frames from one or more streams.</t>

<t>Implementation note: One of the benefits of QUIC is avoidance of head-of-line
blocking across multiple streams.  When a packet loss occurs, only streams with
data in that packet are blocked waiting for a retransmission to be received,
while other streams can continue making progress.  Note that when data from
multiple streams is bundled into a single QUIC packet, loss of that packet
blocks all those streams from making progress.  An implementation is therefore
advised to bundle as few streams as necessary in outgoing packets without losing
transmission efficiency to underfilled packets.</t>

</section>
<section anchor="frame-ack" title="ACK Frame">

<t>Receivers send ACK frames to inform senders which packets they have received and
processed, as well as which packets are considered missing.  The ACK frame
contains between 1 and 256 ACK blocks.  ACK blocks are ranges of acknowledged
packets.</t>

<t>To limit ACK blocks to those that have not yet been received by the sender, the
receiver SHOULD track which ACK frames have been acknowledged by its peer.  Once
an ACK frame has been acknowledged, the packets it acknowledges SHOULD not be
acknowledged again.</t>

<t>A receiver that is only sending ACK frames will not receive acknowledgments for
its packets.  Sending an occasional MAX_DATA or MAX_STREAM_DATA frame as data is
received will ensure that acknowledgements are generated by a peer.  Otherwise,
an endpoint MAY send a PING frame once per RTT to solicit an acknowledgment.</t>

<t>To limit receiver state or the size of ACK frames, a receiver MAY limit the
number of ACK blocks it sends.  A receiver can do this even without receiving
acknowledgment of its ACK frames, with the knowledge this could cause the sender
to unnecessarily retransmit some data.  When this is necessary, the receiver
SHOULD acknowledge newly received packets and stop acknowledging packets
received in the past.</t>

<t>Unlike TCP SACKs, QUIC ACK blocks are cumulative and therefore irrevocable.
Once a packet has been acknowledged, even if it does not appear in a future ACK
frame, it is assumed to be acknowledged.</t>

<t>QUIC ACK frames contain a timestamp section with up to 255 timestamps.
Timestamps enable better congestion control, but are not required for correct
loss recovery, and old timestamps are less valuable, so it is not guaranteed
every timestamp will be received by the sender.  A receiver SHOULD send a
timestamp exactly once for each received packet containing retransmittable
frames. A receiver MAY send timestamps for non-retransmittable packets.
A receiver MUST not send timestamps in unprotected packets.</t>

<t>A sender MAY intentionally skip packet numbers to introduce entropy into the
connection, to avoid opportunistic acknowledgement attacks.  The sender SHOULD
close the connection if an unsent packet number is acknowledged.  The format of
the ACK frame is efficient at expressing blocks of missing packets; skipping
packet numbers between 1 and 255 effectively provides up to 8 bits of efficient
entropy on demand, which should be adequate protection against most
opportunistic acknowledgement attacks.</t>

<t>The type byte for a ACK frame contains embedded flags, and is formatted as
<spanx style="verb">101NLLMM</spanx>.  These bits are parsed as follows:</t>

<t><list style="symbols">
  <t>The first three bits must be set to 101 indicating that this is an ACK frame.</t>
  <t>The <spanx style="verb">N</spanx> bit indicates whether the frame contains a Num Blocks field.</t>
  <t>The two <spanx style="verb">LL</spanx> bits encode the length of the Largest Acknowledged field.
The values 00, 01, 02, and 03 indicate lengths of 8, 16, 32, and 64
bits respectively.</t>
  <t>The two <spanx style="verb">MM</spanx> bits encode the length of the ACK Block Length fields.
The values 00, 01, 02, and 03 indicate lengths of 8, 16, 32, and 64
bits respectively.</t>
</list></t>

<t>An ACK frame is shown below.</t>

<figure title="ACK Frame Format" anchor="ack-format"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Num Blocks(8)]|   NumTS (8)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                Largest Acknowledged (8/16/32/64)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        ACK Delay (16)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     ACK Block Section (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Timestamp Section (*)                   ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the ACK frame are as follows:</t>

<t><list style="hanging">
  <t hangText='Num Blocks (opt):'>
  An optional 8-bit unsigned value specifying the number of additional ACK
blocks (besides the required First ACK Block) in this ACK frame.  Only present
if the ‘N’ flag bit is 1.</t>
  <t hangText='Num Timestamps:'>
  An unsigned 8-bit number specifying the total number of &lt;packet number,
timestamp&gt; pairs in the Timestamp Section.</t>
  <t hangText='Largest Acknowledged:'>
  A variable-sized unsigned value representing the largest packet number the
peer is acknowledging in this packet (typically the largest that the peer has
seen thus far.)</t>
  <t hangText='ACK Delay:'>
  The time from when the largest acknowledged packet, as indicated in the
Largest Acknowledged field, was received by this peer to when this ACK was
sent.</t>
  <t hangText='ACK Block Section:'>
  Contains one or more blocks of packet numbers which have been successfully
received, see <xref target="ack-block-section"/>.</t>
  <t hangText='Timestamp Section:'>
  Contains zero or more timestamps reporting transit delay of received packets.
See <xref target="timestamp-section"/>.</t>
</list></t>

<section anchor="ack-block-section" title="ACK Block Section">

<t>The ACK Block Section contains between one and 256 blocks of packet numbers
which have been successfully received. If the Num Blocks field is absent, only
the First ACK Block length is present in this section. Otherwise, the Num Blocks
field indicates how many additional blocks follow the First ACK Block Length
field.</t>

<figure title="ACK Block Section" anchor="ack-block-format"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              First ACK Block Length (8/16/32/64)            ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 1 (8)]  |       [ACK Block 1 Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap 2 (8)]  |       [ACK Block 2 Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                             ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  [Gap N (8)]  |       [ACK Block N Length (8/16/32/64)]     ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the ACK Block Section are:</t>

<t><list style="hanging">
  <t hangText='First ACK Block Length:'>
  An unsigned packet number delta that indicates the number of contiguous
additional packets being acknowledged starting at the Largest Acknowledged.</t>
  <t hangText='Gap To Next Block (opt, repeated):'>
  An unsigned number specifying the number of contiguous missing packets from
the end of the previous ACK block to the start of the next.  Repeated “Num
Blocks” times.</t>
  <t hangText='ACK Block Length (opt, repeated):'>
  An unsigned packet number delta that indicates the number of contiguous
packets being acknowledged starting after the end of the previous gap.
Repeated “Num Blocks” times.</t>
</list></t>

</section>
<section anchor="timestamp-section" title="Timestamp Section">

<t>The Timestamp Section contains between zero and 255 measurements of packet
receive times relative to the beginning of the connection.</t>

<figure title="Timestamp Section" anchor="timestamp-format"><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+
| [Delta LA (8)]|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    [First Timestamp (32)]                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 1(8)]| [Time Since Previous 1 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA 2(8)]| [Time Since Previous 2 (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                       ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|[Delta LA N(8)]| [Time Since Previous N (16)]  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the Timestamp Section are:</t>

<t><list style="hanging">
  <t hangText='Delta Largest Acknowledged (opt):'>
  An optional 8-bit unsigned packet number delta specifying the delta between
the largest acknowledged and the first packet whose timestamp is being
reported.  In other words, this first packet number may be computed as
(Largest Acknowledged - Delta Largest Acknowledged.)</t>
  <t hangText='First Timestamp (opt):'>
  An optional 32-bit unsigned value specifying the time delta in microseconds,
from the beginning of the connection to the arrival of the packet indicated by
Delta Largest Acknowledged.</t>
  <t hangText='Delta Largest Acked 1..N (opt, repeated):'>
  This field has the same semantics and format as “Delta Largest Acknowledged”.
Repeated “Num Timestamps - 1” times.</t>
  <t hangText='Time Since Previous Timestamp 1..N(opt, repeated):'>
  An optional 16-bit unsigned value specifying time delta from the previous
reported timestamp.  It is encoded in the same format as the ACK Delay.
Repeated “Num Timestamps - 1” times.</t>
</list></t>

<t>The timestamp section lists packet receipt timestamps ordered by timestamp.</t>

<section anchor="time-format" title="Time Format">

<t>DISCUSS_AND_REPLACE: Perhaps make this format simpler.</t>

<t>The time format used in the ACK frame above is a 16-bit unsigned float with 11
explicit bits of mantissa and 5 bits of explicit exponent, specifying time in
microseconds.  The bit format is loosely modeled after IEEE 754.  For example, 1
microsecond is represented as 0x1, which has an exponent of zero, presented in
the 5 high order bits, and mantissa of 1, presented in the 11 low order bits.
When the explicit exponent is greater than zero, an implicit high-order 12th bit
of 1 is assumed in the mantissa.  For example, a floating value of 0x800 has an
explicit exponent of 1, as well as an explicit mantissa of 0, but then has an
effective mantissa of 4096 (12th bit is assumed to be 1).  Additionally, the
actual exponent is one-less than the explicit exponent, and the value represents
4096 microseconds.  Any values larger than the representable range are clamped
to 0xFFFF.</t>

</section>
</section>
<section anchor="ack-frames-and-packet-protection" title="ACK Frames and Packet Protection">

<t>ACK frames that acknowledge protected packets MUST be carried in a packet that
has an equivalent or greater level of packet protection.</t>

<t>Packets that are protected with 1-RTT keys MUST be acknowledged in packets that
are also protected with 1-RTT keys.</t>

<t>A packet that is not protected and claims to acknowledge a packet number that
was sent with packet protection is not valid.  An unprotected packet that
carries acknowledgments for protected packets MUST be discarded in its entirety.</t>

<t>Packets that a client sends with 0-RTT packet protection MUST be acknowledged by
the server in packets protected by 1-RTT keys.  This can mean that the client is
unable to use these acknowledgments if the server cryptographic handshake
messages are delayed or lost.  Note that the same limitation applies to other
data sent by the server protected by the 1-RTT keys.</t>

<t>Unprotected packets, such as those that carry the initial cryptographic
handshake messages, MAY be acknowledged in unprotected packets.  Unprotected
packets are vulnerable to falsification or modification.  Unprotected packets
can be acknowledged along with protected packets in a protected packet.</t>

<t>An endpoint SHOULD acknowledge packets containing cryptographic handshake
messages in the next unprotected packet that it sends, unless it is able to
acknowledge those packets in later packets protected by 1-RTT keys.  At the
completion of the cryptographic handshake, both peers send unprotected packets
containing cryptographic handshake messages followed by packets protected by
1-RTT keys. An endpoint SHOULD acknowledge the unprotected packets that complete
the cryptographic handshake in a protected packet, because its peer is
guaranteed to have access to 1-RTT packet protection keys.</t>

<t>For instance, a server acknowledges a TLS ClientHello in the packet that carries
the TLS ServerHello; similarly, a client can acknowledge a TLS HelloRetryRequest
in the packet containing a second TLS ClientHello.  The complete set of server
handshake messages (TLS ServerHello through to Finished) might be acknowledged
by a client in protected packets, because it is certain that the server is able
to decipher the packet.</t>

</section>
</section>
<section anchor="frame-max-data" title="MAX_DATA Frame">

<t>The MAX_DATA frame (type=0x04) is used in flow control to inform the peer of
the maximum amount of data that can be sent on the connection as a whole.</t>

<t>The frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Maximum Data (64)                      +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the MAX_DATA frame are as follows:</t>

<t><list style="hanging">
  <t hangText='Maximum Data:'>
  A 64-bit unsigned integer indicating the maximum amount of data that can be
sent on the entire connection, in units of 1024 octets.  That is, the updated
connection-level data limit is determined by multiplying the encoded value by
1024.</t>
</list></t>

<t>All data sent in STREAM frames counts toward this limit, with the exception of
data on stream 0.  The sum of the largest received offsets on all streams -
including closed streams, but excluding stream 0 - MUST NOT exceed the value
advertised by a receiver.  An endpoint MUST terminate a connection with a
QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error if it receives more data than the
maximum data value that it has sent, unless this is a result of a change in the
initial limits (see <xref target="zerortt-parameters"/>).</t>

</section>
<section anchor="frame-max-stream-data" title="MAX_STREAM_DATA Frame">

<t>The MAX_STREAM_DATA frame (type=0x05) is used in flow control to inform a peer
of the maximum amount of data that can be sent on a stream.</t>

<t>The frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                    Maximum Stream Data (64)                   +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the MAX_STREAM_DATA frame are as follows:</t>

<t><list style="hanging">
  <t hangText='Stream ID:'>
  The stream ID of the stream that is affected.</t>
  <t hangText='Maximum Stream Data:'>
  A 64-bit unsigned integer indicating the maximum amount of data that can be
sent on the identified stream, in units of octets.</t>
</list></t>

<t>When counting data toward this limit, an endpoint accounts for the largest
received offset of data that is sent or received on the stream.  Loss or
reordering can mean that the largest received offset on a stream can be greater
than the total size of data received on that stream.  Receiving STREAM frames
might not increase the largest received offset.</t>

<t>The data sent on a stream MUST NOT exceed the largest maximum stream data value
advertised by the receiver.  An endpoint MUST terminate a connection with a
QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error if it receives more data than the
largest maximum stream data that it has sent for the affected stream, unless
this is a result of a change in the initial limits (see <xref target="zerortt-parameters"/>).</t>

</section>
<section anchor="frame-max-stream-id" title="MAX_STREAM_ID Frame">

<t>The MAX_STREAM_ID frame (type=0x06) informs the peer of the maximum stream ID
that they are permitted to open.</t>

<t>The frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Maximum Stream ID (32)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields in the MAX_STREAM_ID frame are as follows:</t>

<t><list style="hanging">
  <t hangText='Maximum Stream ID:'>
  ID of the maximum peer-initiated stream ID for the connection.</t>
</list></t>

<t>Loss or reordering can mean that a MAX_STREAM_ID frame can be received which
states a lower stream limit than the client has previously received.
MAX_STREAM_ID frames which do not increase the maximum stream ID MUST be
ignored.</t>

<t>A peer MUST NOT initiate a stream with a higher stream ID than the greatest
maximum stream ID it has received.  An endpoint MUST terminate a connection with
a QUIC_TOO_MANY_OPEN_STREAMS error if a peer initiates a stream with a higher
stream ID than it has sent, unless this is a result of a change in the initial
limits (see <xref target="zerortt-parameters"/>).</t>

</section>
<section anchor="frame-blocked" title="BLOCKED Frame">

<t>A sender sends a BLOCKED frame (type=0x08) when it wishes to send data, but is
unable to due to connection-level flow control (see <xref target="blocking"/>). BLOCKED
frames can be used as input to tuning of flow control algorithms (see
<xref target="fc-credit"/>).</t>

<t>The BLOCKED frame does not contain a payload.</t>

</section>
<section anchor="frame-stream-blocked" title="STREAM_BLOCKED Frame">

<t>A sender sends a STREAM_BLOCKED frame (type=0x09) when it wishes to send data,
but is unable to due to stream-level flow control.  This frame is analogous to
BLOCKED (<xref target="frame-blocked"/>).</t>

<t>The STREAM_BLOCKED frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The STREAM_BLOCKED frame contains a single field:</t>

<t><list style="hanging">
  <t hangText='Stream ID:'>
  A 32-bit unsigned number indicating the stream which is flow control blocked.</t>
</list></t>

<t>An endpoint MAY send a STREAM_BLOCKED frame for a stream that exceeds the
maximum stream ID set by its peer (see <xref target="frame-max-stream-id"/>).  This does not
open the stream, but informs the peer that a new stream was needed, but the
stream limit prevented the creation of the stream.</t>

</section>
<section anchor="frame-stream-id-needed" title="STREAM_ID_NEEDED Frame">

<t>A sender sends a STREAM_ID_NEEDED frame (type=0x0a) when it wishes to open a
stream, but is unable to due to the maximum stream ID limit.</t>

<t>The STREAM_ID_NEEDED frame does not contain a payload.</t>

</section>
<section anchor="frame-rst-stream" title="RST_STREAM Frame">

<t>An endpoint may use a RST_STREAM frame (type=0x01) to abruptly terminate a
stream.</t>

<t>After sending a RST_STREAM, an endpoint ceases transmission of STREAM frames on
the identified stream.  A receiver of RST_STREAM can discard any data that it
already received on that stream.  An endpoint sends a RST_STREAM in response to
a RST_STREAM unless the stream is already closed.</t>

<t>The RST_STREAM frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Stream ID (32)                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       Final Offset (64)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields are:</t>

<t><list style="hanging">
  <t hangText='Stream ID:'>
  The 32-bit Stream ID of the stream being terminated.</t>
  <t hangText='Error code:'>
  A 32-bit error code which indicates why the stream is being closed.</t>
  <t hangText='Final offset:'>
  A 64-bit unsigned integer indicating the absolute byte offset of the end of
data written on this stream by the RST_STREAM sender.</t>
</list></t>

</section>
<section anchor="frame-padding" title="PADDING Frame">

<t>The PADDING frame (type=0x00) has no semantic value.  PADDING frames can be used
to increase the size of a packet.  Padding can be used to increase an initial
client packet to the minimum required size, or to provide protection against
traffic analysis for protected packets.</t>

<t>A PADDING frame has no content.  That is, a PADDING frame consists of the single
octet that identifies the frame as a PADDING frame.</t>

</section>
<section anchor="frame-ping" title="PING frame">

<t>Endpoints can use PING frames (type=0x07) to verify that their peers are still
alive or to check reachability to the peer. The PING frame contains no
additional fields. The receiver of a PING frame simply needs to acknowledge the
packet containing this frame. The PING frame SHOULD be used to keep a connection
alive when a stream is open. The default is to send a PING frame after 15
seconds of quiescence. A PING frame has no additional fields.</t>

</section>
<section anchor="frame-new-connection-id" title="NEW_CONNECTION_ID Frame">

<t>A server sends a NEW_CONNECTION_ID to provide the client with alternative
connection IDs that can be used to break linkability when migrating connections
(see <xref target="migration-linkability"/>).</t>

<t>The NEW_CONNECTION_ID is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Sequence (16)           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        Connection ID (64)                     +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields are:</t>

<t><list style="hanging">
  <t hangText='Sequence:'>
  A 16-bit sequence number.  This value starts at 0 and increases by 1 for each
connection ID that is provided by the server.  The sequence value can wrap;
the value 65535 is followed by 0.  When wrapping the sequence field, the
server MUST ensure that a value with the same sequence has been received and
acknowledged by the client.  The connection ID that is assigned during the
handshake is assumed to have a sequence of 65535.</t>
  <t hangText='Connection ID:'>
  A 64-bit connection ID.</t>
</list></t>

</section>
<section anchor="frame-connection-close" title="CONNECTION_CLOSE frame">

<t>An endpoint sends a CONNECTION_CLOSE frame (type=0x02) to notify its peer that
the connection is being closed.  If there are open streams that haven’t been
explicitly closed, they are implicitly closed when the connection is closed.
(Ideally, a GOAWAY frame would be sent with enough time that all streams are
torn down.)  The frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Error Code (32)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Reason Phrase Length (16)   |      [Reason Phrase (*)]    ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields of a CONNECTION_CLOSE frame are as follows:</t>

<t><list style="hanging">
  <t hangText='Error Code:'>
  A 32-bit error code which indicates the reason for closing this connection.</t>
  <t hangText='Reason Phrase Length:'>
  A 16-bit unsigned number specifying the length of the reason phrase.  Note
that a CONNECTION_CLOSE frame cannot be split between packets, so in practice
any limits on packet size will also limit the space available for a reason
phrase.</t>
  <t hangText='Reason Phrase:'>
  A human-readable explanation for why the connection was closed.  This can be
zero length if the sender chooses to not give details beyond the Error Code.
This SHOULD be a UTF-8 encoded string <xref target="RFC3629"/>.</t>
</list></t>

</section>
<section anchor="frame-goaway" title="GOAWAY Frame">

<t>An endpoint uses a GOAWAY frame (type=0x03) to initiate a graceful shutdown of a
connection.  The endpoints will continue to use any active streams, but the
sender of the GOAWAY will not initiate or accept any additional streams beyond
those indicated.  The GOAWAY frame is as follows:</t>

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Largest Client Stream ID (32)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Largest Server Stream ID (32)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The fields of a GOAWAY frame are:</t>

<t><list style="hanging">
  <t hangText='Largest Client Stream ID:'>
  The highest-numbered, client-initiated stream on which the endpoint sending
the GOAWAY frame either sent data, or received and delivered data.  All
higher-numbered, client-initiated streams (that is, odd-numbered streams) are
implicitly reset by sending or receiving the GOAWAY frame.</t>
  <t hangText='Largest Server Stream ID:'>
  The highest-numbered, server-initiated stream on which the endpoint sending
the GOAWAY frame either sent data, or received and delivered data.  All
higher-numbered, server-initiated streams (that is, even-numbered streams) are
implicitly reset by sending or receiving the GOAWAY frame.</t>
</list></t>

<t>A GOAWAY frame indicates that any application layer actions on streams with
higher numbers than those indicated can be safely retried because no data was
exchanged.  An endpoint MUST set the value of the Largest Client or Server
Stream ID to be at least as high as the highest-numbered stream on which it
either sent data or received and delivered data to the application protocol that
uses QUIC.</t>

<t>An endpoint MAY choose a larger stream identifier if it wishes to allow for a
number of streams to be created.  This is especially valuable for peer-initiated
streams where packets creating new streams could be in transit; using a larger
stream number allows those streams to complete.</t>

<t>In addition to initiating a graceful shutdown of a connection, GOAWAY MAY be
sent immediately prior to sending a CONNECTION_CLOSE frame that is sent as a
result of detecting a fatal error.  Higher-numbered streams than those indicated
in the GOAWAY frame can then be retried.</t>

</section>
</section>
<section anchor="packetization" title="Packetization and Reliability">

<t>The Path Maximum Transmission Unit (PMTU) is the maximum size of the entire IP
header, UDP header, and UDP payload. The UDP payload includes the QUIC public
header, protected payload, and any authentication fields.</t>

<t>All QUIC packets SHOULD be sized to fit within the estimated PMTU to avoid IP
fragmentation or packet drops. To optimize bandwidth efficiency, endpoints
SHOULD use Packetization Layer PMTU Discovery (<xref target="RFC4821"/>) and MAY use PMTU
Discovery (<xref target="RFC1191"/>, <xref target="RFC1981"/>) for detecting the PMTU, setting the PMTU
appropriately, and storing the result of previous PMTU determinations.</t>

<t>In the absence of these mechanisms, QUIC endpoints SHOULD NOT send IP packets
larger than 1280 octets. Assuming the minimum IP header size, this results in
a QUIC packet size of 1232 octets for IPv6 and 1252 octets for IPv4.</t>

<t>QUIC endpoints that implement any kind of PMTU discovery SHOULD maintain an
estimate for each combination of local and remote IP addresses (as each pairing
could have a different maximum MTU in the path).</t>

<t>QUIC depends on the network path supporting a MTU of at least 1280 octets. This
is the IPv6 minimum and therefore also supported by most modern IPv4 networks.
An endpoint MUST NOT reduce their MTU below this number, even if it receives
signals that indicate a smaller limit might exist.</t>

<t>Clients MUST ensure that the first packet in a connection, and any
retransmissions of those octets, has a QUIC packet size of least 1232 octets for
an IPv6 packet and 1252 octets for an IPv4 packet.  In the absence of extensions
to the IP header, padding to exactly these values will result in an IP packet
that is 1280 octets.</t>

<t>The initial client packet SHOULD be padded to exactly these values unless the
client has a reasonable assurance that the PMTU is larger.  Sending a packet of
this size ensures that the network path supports an MTU of this size and helps
reduce the amplitude of amplification attacks caused by server responses toward
an unverified client address.</t>

<t>Servers MUST ignore an initial plaintext packet from a client if its total size
is less than 1232 octets for IPv6 or 1252 octets for IPv4.</t>

<t>If a QUIC endpoint determines that the PMTU between any pair of local and remote
IP addresses has fallen below 1280 octets, it MUST immediately cease sending
QUIC packets on the affected path.  This could result in termination of the
connection if an alternative path cannot be found.</t>

<t>A sender bundles one or more frames in a Regular QUIC packet (see <xref target="frames"/>).</t>

<t>A sender SHOULD minimize per-packet bandwidth and computational costs by
bundling as many frames as possible within a QUIC packet.  A sender MAY wait for
a short period of time to bundle multiple frames before sending a packet that is
not maximally packed, to avoid sending out large numbers of small packets.  An
implementation may use heuristics about expected application sending behavior to
determine whether and for how long to wait.  This waiting period is an
implementation decision, and an implementation should be careful to delay
conservatively, since any delay is likely to increase application-visible
latency.</t>

<t>Regular QUIC packets are “containers” of frames; a packet is never retransmitted
whole.  How an endpoint handles the loss of the frame depends on the type of the
frame.  Some frames are simply retransmitted, some have their contents moved to
new frames, and others are never retransmitted.</t>

<t>When a packet is detected as lost, the sender re-sends any frames as necessary:</t>

<t><list style="symbols">
  <t>All application data sent in STREAM frames MUST be retransmitted, unless the
endpoint has sent a RST_STREAM for that stream.  When an endpoint sends a
RST_STREAM frame, data outstanding on that stream SHOULD NOT be retransmitted,
since subsequent data on this stream is expected to not be delivered by the
receiver.</t>
  <t>ACK and PADDING frames MUST NOT be retransmitted.  ACK frames are cumulative,
so new frames containing updated information will be sent as described in
<xref target="frame-ack"/>.</t>
  <t>All other frames MUST be retransmitted.</t>
</list></t>

<t>Upon detecting losses, a sender MUST take appropriate congestion control action.
The details of loss detection and congestion control are described in
<xref target="QUIC-RECOVERY"/>.</t>

<t>A packet MUST NOT be acknowledged until packet protection has been successfully
removed and all frames contained in the packet have been processed.  For STREAM
frames, this means the data has been queued (but not necessarily delivered to
the application).  This also means that any stream state transitions triggered
by STREAM or RST_STREAM frames have occurred. Once the packet has been fully
processed, a receiver acknowledges receipt by sending one or more ACK frames
containing the packet number of the received packet.</t>

<t>To avoid creating an indefinite feedback loop, an endpoint MUST NOT generate an
ACK frame in response to a packet containing only ACK or PADDING frames.</t>

<t>Strategies and implications of the frequency of generating acknowledgments are
discussed in more detail in <xref target="QUIC-RECOVERY"/>.</t>

<section anchor="special-considerations-for-pmtu-discovery" title="Special Considerations for PMTU Discovery">

<t>Traditional ICMP-based path MTU discovery in IPv4 <xref target="RFC1191"/> is potentially
vulnerable to off-path attacks that successfully guess the IP/port 4-tuple and
reduce the MTU to a bandwidth-inefficient value. TCP connections mitigate this
risk by using the (at minimum) 8 bytes of transport header echoed in the ICMP
message to validate the TCP sequence number as valid for the current
connection. However, as QUIC operates over UDP, in IPv4 the echoed information
could consist only of the IP and UDP headers, which usually has insufficient
entropy to mitigate off-path attacks.</t>

<t>As a result, endpoints that implement PMTUD in IPv4 SHOULD take steps to
mitigate this risk. For instance, an application could:</t>

<t><list style="symbols">
  <t>Set the IPv4 Don’t Fragment (DF) bit on a small proportion of packets, so that
most invalid ICMP messages arrive when there are no DF packets outstanding, and
can therefore be identified as spurious.</t>
  <t>Store additional information from the IP or UDP headers from DF packets (for
example, the IP ID or UDP checksum) to further authenticate incoming Datagram
Too Big messages.</t>
  <t>Any reduction in PMTU due to a report contained in an ICMP packet is
provisional until QUIC’s loss detection algorithm determines that the packet is
actually lost.</t>
</list></t>

</section>
</section>
<section anchor="streams" title="Streams: QUIC’s Data Structuring Abstraction">

<t>Streams in QUIC provide a lightweight, ordered, unidirectional byte-stream.</t>

<t>Streams can be created either by the client or the server, can concurrently send
data interleaved with other streams, and can be cancelled.</t>

<t>Data that is received on a stream is delivered in order within that stream, but
there is no particular delivery order across streams.  Transmit ordering among
streams is left to the implementation.</t>

<t>The creation and destruction of streams are expected to have minimal bandwidth
and computational cost.  A single STREAM frame may create, carry data for, and
terminate a stream, or a stream may last the entire duration of a connection.</t>

<t>Streams are individually flow controlled, allowing an endpoint to limit memory
commitment and to apply back pressure.  The creation of streams is also flow
controlled, with each peer declaring the maximum stream ID it is willing to
accept at a given time.</t>

<t>An alternative view of QUIC streams is as an elastic “message” abstraction,
similar to the way ephemeral streams are used in SST
<xref target="SST"/>, which may be a more appealing description
for some applications.</t>

<section anchor="stream-id" title="Stream Identifiers">

<t>Streams are identified by an unsigned 32-bit integer, referred to as the Stream
ID.  A separate identifier space is used for streams sent by each peer.</t>

<t>Stream ID 0 in both directions is reserved for the cryptographic handshake.
Both client and server send cryptographic handshake messages on their stream 0.
Stream 0 MUST NOT be used for application data.</t>

<t>A QUIC endpoint cannot reuse a Stream ID.  Streams MUST be created in sequential
order.  Open streams can be used in any order.  Streams that are used out of
order result in lower-numbered streams in the same direction being counted as
open.</t>

<t>Stream IDs are usually encoded as a 32-bit integer, though the STREAM frame
(<xref target="frame-stream"/>) permits a shorter encoding when the leading bits of the
stream ID are zero.</t>

</section>
<section anchor="stream-states" title="Stream States">

<t>Endpoints do not coordinate the creation of streams; they are created
unilaterally by the sending endpoint.</t>

<t>Transitions between stream states (“idle”, “open”, and “closed”) is only
triggered by frames that are sent by the sending endpoint.  However,
state-affecting frames can arrive out of order at the receiving endpoint,
leading to a different set of valid transitions for receiving streams.</t>

<section anchor="stream-states-for-sending" title="Stream States for Sending">

<t><xref target="stream-state-send"/> illustrates the states and transitions that apply to a
stream at the sender of that stream.</t>

<figure title="Stream States for Sending" anchor="stream-state-send"><artwork><![CDATA[
                            +--------+
                            |        |
                            |  idle  |
                            |        |
                            +--------+
                                 |
                      send STREAM or RST_STREAM
                                 |
                                 v
                            +--------+
                            |        |
                            |  open  |
                            |        |
                            +--------+
                                 |
                      send STREAM with FIN flag
                         send RST_STREAM
                                 |
                                 v
                            +--------+
                            |        |
                            | closed |
                            |        |
                            +--------+
]]></artwork></figure>

</section>
<section anchor="stream-states-for-receiving" title="Stream States for Receiving">

<t><xref target="stream-state-recv"/> illustrates the states and transitions that apply to a
stream at the receiving endpoint.</t>

<figure title="Stream States for Receipt" anchor="stream-state-recv"><artwork><![CDATA[
                            +--------+
                            |        |
                            |  idle  |
                            |        |
                            +--------+
                                 |
                     receive STREAM, RST_STREAM or
                           STREAM_BLOCKED
                     or receive these frames for a
                         higher-numbered stream
                                 |
                                 v
                            +--------+
                            |        |
                            |  open  |
                            |        |
                            +--------+
                                 |
                     receive STREAM with FIN flag
                        receive RST_STREAM
                                 |
                                 v
                            +--------+
                            |        |
                            | closed |
                            |        |
                            +--------+
]]></artwork></figure>

<t>The recipient of a stream will have a delayed view of the state of streams at
its peer.  Loss or delay of frames can cause frames to arrive out of order.</t>

</section>
<section anchor="the-idle-state" title="The “idle” State">

<t>All streams start in the “idle” state.</t>

<t>The following transitions are valid from this state:</t>

<t>Sending a STREAM or RST_STREAM frame causes the identified stream to become
“open” for a sending endpoint.  New streams use the next available stream
identifier, as described in <xref target="stream-id"/>.  An endpoint MUST NOT send a STREAM
or RST_STREAM frame for a stream ID that is higher than the peers advertised
maximum stream ID (see <xref target="frame-max-stream-id"/>).  An endpoint MUST treat
receiving a STREAM or RST_STREAM frame for stream above the maximum as a
QUIC_TOO_MANY_OPEN_STREAMS error.</t>

<t>Receiving a STREAM, RST_STREAM, or STREAM_BLOCKED frame causes a stream to
become “open” for a receiving endpoint.</t>

<t>A RST_STREAM frame, or a STREAM frame with the FIN flag set also causes a stream
to become “closed” immediately afterwards.</t>

<t><list style="hanging">
  <t hangText='Note:'>
  An endpoint should not need to send a RST_STREAM frame on an “idle” stream,
unless specifically mandated by the application protocol.</t>
</list></t>

</section>
<section anchor="the-open-state" title="The “open” State">

<t>A stream in the “open” state is used for transmission of data in STREAM frames.</t>

<t>The sending peer can send STREAM, RST_STREAM and STREAM_BLOCKED frames in this
state.  A receiving peer sends MAX_STREAM_DATA frames.</t>

<t>In this state the sending endpoint MUST observe the flow control limits
advertised by the receiving endpoint (see <xref target="flow-control"/>).</t>

<t>Opening a stream causes all lower-numbered streams in the same direction to
become open.  Endpoints open streams in increasing numeric order,
but loss or reordering can cause packets that open streams to arrive out of
order.</t>

<t>From the “open” state, the sending endpoint causes the stream to become “closed”
by sending a RST_STREAM frame, or by sending a STREAM frame with the FIN flag
set after sending all preceding data.</t>

<t>A stream becomes “closed” at the receiving endpoint when a RST_STREAM frame is
received or when all data is received and a STREAM frame with a FIN flag is
received.</t>

</section>
<section anchor="the-closed-state" title="The “closed” State">

<t>A “closed” stream cannot be used for sending any stream-related frames.</t>

<t>In the “closed” state, a sending endpoint can retransmit data that has already
been sent in STREAM frames, or retransmit a RST_STREAM frame.  Retransmission of
data is permitted if the packets carrying the original data are determined to
have been lost.</t>

<t>An endpoint will know the final offset of the data it receives on a stream when
it reaches the “closed” state, see <xref target="final-offset"/> for details.</t>

<t>An endpoint could continue receiving frames for the stream even after the stream
is closed for sending if packets are reordered.  At the receiving endpoint,
retransmissions of data in STREAM frames, or retransmissions of STREAM_BLOCKED
and RST_STREAM frames might arrive after the stream becomes “closed”.  At the
sending endpoint, MAX_STREAM_DATA frames might be received after the stream
becomes “closed”.  Frames received on a “closed” stream SHOULD be discarded.  An
endpoint MAY choose to limit the period over which it ignores frames and treat
frames that arrive after this time as being in error.</t>

</section>
</section>
<section anchor="stream-concurrency" title="Stream Concurrency">

<t>An endpoint limits the number of concurrently active incoming streams by
adjusting the maximum stream ID.  An initial value is set in the transport
parameters (see <xref target="transport-parameter-definitions"/>) and is subsequently
increased by MAX_STREAM_ID frames (see <xref target="frame-max-stream-id"/>).</t>

<t>The maximum stream ID is specific to each endpoint and applies only to the peer
that receives the setting. That is, clients specify the maximum stream ID the
server can initiate, and servers specify the maximum stream ID the client can
initiate.  Each endpoint may respond on streams initiated by the other peer,
regardless of whether it is permitted to initiated new streams.</t>

<t>Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that
receives a STREAM frame with an ID greater than the limit it has sent MUST treat
this as a stream error of type QUIC_TOO_MANY_OPEN_STREAMS (<xref target="error-handling"/>),
unless this is a result of a change in the initial offsets (see
<xref target="zerortt-parameters"/>).</t>

<t>A receiver MUST NOT renege on an advertisement; that is, once a receiver
advertises a stream ID via a MAX_STREAM_ID frame, it MUST NOT subsequently
advertise a smaller maximum ID.  A sender may receive MAX_STREAM_ID frames out
of order; a sender MUST therefore ignore any MAX_STREAM_ID that does not
increase the maximum.</t>

</section>
<section anchor="sending-and-receiving-data" title="Sending and Receiving Data">

<t>Once a stream is created, endpoints may use the stream to send and receive data.
Each endpoint may send a series of STREAM frames encapsulating data on a stream
until the stream is terminated in that direction.  Streams are an ordered
byte-stream abstraction, and they have no other structure within them.  STREAM
frame boundaries are not expected to be preserved in retransmissions from the
sender or during delivery to the application at the receiver.</t>

<t>When new data is to be sent on a stream, a sender MUST set the encapsulating
STREAM frame’s offset field to the stream offset of the first byte of this new
data.  The first byte of data that is sent on a stream has the stream offset 0.
The largest offset delivered on a stream MUST be less than 2^64. A receiver
MUST ensure that received stream data is delivered to the application as an
ordered byte-stream.  Data received out of order MUST be buffered for later
delivery, as long as it is not in violation of the receiver’s flow control
limits.</t>

<t>An endpoint MUST NOT send data on any stream without ensuring that it is within
the data limits set by its peer.  The cryptographic handshake stream, Stream 0,
is exempt from the connection-level data limits established by MAX_DATA.  Stream
0 is still subject to stream-level data limits and MAX_STREAM_DATA.</t>

<t>Flow control is described in detail in <xref target="flow-control"/>, and congestion control
is described in the companion document <xref target="QUIC-RECOVERY"/>.</t>

</section>
<section anchor="stream-prioritization" title="Stream Prioritization">

<t>Stream multiplexing has a significant effect on application performance if
resources allocated to streams are correctly prioritized.  Experience with other
multiplexed protocols, such as HTTP/2 <xref target="RFC7540"/>, shows that effective
prioritization strategies have a significant positive impact on performance.</t>

<t>QUIC does not provide frames for exchanging prioritization information.  Instead
it relies on receiving priority information from the application that uses QUIC.
Protocols that use QUIC are able to define any prioritization scheme that suits
their application semantics.  A protocol might define explicit messages for
signaling priority, such as those defined in HTTP/2; it could define rules that
allow an endpoint to determine priority based on context; or it could leave the
determination to the application.</t>

<t>A QUIC implementation SHOULD provide ways in which an application can indicate
the relative priority of streams.  When deciding which streams to dedicate
resources to, QUIC SHOULD use the information provided by the application.
Failure to account for priority of streams can result in suboptimal performance.</t>

<t>Stream priority is most relevant when deciding which stream data will be
transmitted.  Often, there will be limits on what can be transmitted as a result
of connection flow control or the current congestion controller state.</t>

<t>Giving preference to the transmission of its own management frames ensures that
the protocol functions efficiently.  That is, prioritizing frames other than
STREAM frames ensures that loss recovery, congestion control, and flow control
operate effectively.</t>

<t>Stream 0 MUST be prioritized over other streams prior to the completion of the
cryptographic handshake.  This includes the retransmission of the second flight
of client handshake messages, that is, the TLS Finished and any client
authentication messages.</t>

<t>STREAM frames that are determined to be lost SHOULD be retransmitted before
sending new data, unless application priorities indicate otherwise.
Retransmitting lost STREAM frames can fill in gaps, which allows the peer to
consume already received data and free up flow control window.</t>

</section>
</section>
<section anchor="flow-control" title="Flow Control">

<t>It is necessary to limit the amount of data that a sender may have outstanding
at any time, so as to prevent a fast sender from overwhelming a slow receiver,
or to prevent a malicious sender from consuming significant resources at a
receiver.  This section describes QUIC’s flow-control mechanisms.</t>

<t>QUIC employs a credit-based flow-control scheme similar to HTTP/2’s flow control
<xref target="RFC7540"/>.  A receiver advertises the number of octets it is prepared to
receive on a given stream and for the entire connection.  This leads to two
levels of flow control in QUIC: (i) Connection flow control, which prevents
senders from exceeding a receiver’s buffer capacity for the connection, and (ii)
Stream flow control, which prevents a single stream from consuming the entire
receive buffer for a connection.</t>

<t>A receiver sends MAX_DATA or MAX_STREAM_DATA frames to the sender to advertise
additional credit by sending the absolute byte offset in the connection or
stream which it is willing to receive.</t>

<t>A receiver MAY advertise a larger offset at any point by sending MAX_DATA or
MAX_STREAM_DATA frames.  A receiver MUST NOT renege on an advertisement; that
is, once a receiver advertises an offset, it MUST NOT subsequently advertise a
smaller offset.  A sender could receive MAX_DATA or MAX_STREAM_DATA frames out
of order; a sender MUST therefore ignore any flow control offset that does not
move the window forward.</t>

<t>A receiver MUST close the connection with a
QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA error (<xref target="error-handling"/>) if the
peer violates the advertised connection or stream data limits.</t>

<t>A sender MUST send BLOCKED frames to indicate it has data to write but is
blocked by lack of connection or stream flow control credit.  BLOCKED frames are
expected to be sent infrequently in common cases, but they are considered useful
for debugging and monitoring purposes.</t>

<t>A receiver advertises credit for a stream by sending a MAX_STREAM_DATA frame
with the Stream ID set appropriately. A receiver could use the current offset of
data consumed to determine the flow control offset to be advertised.  A receiver
MAY send MAX_STREAM_DATA frames in multiple packets in order to make sure that
the sender receives an update before running out of flow control credit, even if
one of the packets is lost.</t>

<t>Connection flow control is a limit to the total bytes of stream data sent in
STREAM frames on all streams.  A receiver advertises credit for a connection by
sending a MAX_DATA frame.  A receiver maintains a cumulative sum of bytes
received on all streams, which are used to check for flow control violations. A
receiver might use a sum of bytes consumed on all contributing streams to
determine the maximum data limit to be advertised.</t>

<section anchor="edge-cases-and-other-considerations" title="Edge Cases and Other Considerations">

<t>There are some edge cases which must be considered when dealing with stream and
connection level flow control.  Given enough time, both endpoints must agree on
flow control state.  If one end believes it can send more than the other end is
willing to receive, the connection will be torn down when too much data arrives.</t>

<t>Conversely if a sender believes it is blocked, while endpoint B expects more
data can be received, then the connection can be in a deadlock, with the sender
waiting for a MAX_DATA or MAX_STREAM_DATA frame which will never come.</t>

<t>On receipt of a RST_STREAM frame, an endpoint will tear down state for the
matching stream and ignore further data arriving on that stream.  This could
result in the endpoints getting out of sync, since the RST_STREAM frame may have
arrived out of order and there may be further bytes in flight.  The data sender
would have counted the data against its connection level flow control budget,
but a receiver that has not received these bytes would not know to include them
as well.  The receiver must learn the number of bytes that were sent on the
stream to make the same adjustment in its connection flow controller.</t>

<t>To avoid this de-synchronization, a RST_STREAM frame includes the final byte
offset sent on the stream in the RST_STREAM frame (see <xref target="final-offset"/>).  On
receiving a RST_STREAM frame, a receiver definitively knows how many bytes were
sent on that stream before the RST_STREAM frame, and the receiver MUST use the
final offset to account for all bytes sent on the stream in its connection level
flow controller.</t>

<section anchor="fc-credit" title="Data Limit Increments">

<t>This document leaves when and how many bytes to advertise in a MAX_DATA or
MAX_STREAM_DATA to implementations, but offers a few considerations.  These
frames contribute to connection overhead.  Therefore frequently sending frames
with small changes is undesirable.  At the same time, infrequent updates require
larger increments to limits if blocking is to be avoided.  Thus, larger updates
require a receiver to make larger resource commitments.  Thus there is a
tradeoff between resource commitment and overhead when determining how large a
limit is advertised.</t>

<t>A receiver MAY use an autotuning mechanism to tune the frequency and amount that
it increases data limits based on a roundtrip time estimate and the rate at
which the receiving application consumes data, similar to common TCP
implementations.</t>

</section>
</section>
<section anchor="stream-limit-increment" title="Stream Limit Increment">

<t>As with flow control, this document leaves when and how many streams to make
available to a peer via MAX_STREAM_ID to implementations, but offers a few
considerations.  MAX_STREAM_ID frames constitute minimal overhead, while
withholding MAX_STREAM_ID frames can prevent the peer from using the available
parallelism.</t>

<t>Implementations will likely want to increase the maximum stream ID as
peer-initiated streams close.  A receiver MAY also advance the maximum stream ID
based on current activity, system conditions, and other environmental factors.</t>

<section anchor="blocking" title="Blocking on Flow Control">

<t>If a sender does not receive a MAX_DATA or MAX_STREAM_DATA frame when it has run
out of flow control credit, the sender will be blocked and MUST send a BLOCKED
or STREAM_BLOCKED frame.  These frames are expected to be useful for debugging
at the receiver; they do not require any other action.  A receiver SHOULD NOT
wait for a BLOCKED or STREAM_BLOCKED frame before sending MAX_DATA or
MAX_STREAM_DATA, since doing so will mean that a sender is unable to send for an
entire round trip.</t>

<t>For smooth operation of the congestion controller, it is generally considered
best to not let the sender go into quiescence if avoidable.  To avoid blocking a
sender, and to reasonably account for the possibiity of loss, a receiver should
send a MAX_DATA or MAX_STREAM_DATA frame at least two roundtrips before it
expects the sender to get blocked.</t>

<t>A sender sends a single BLOCKED or STREAM_BLOCKED frame only once when it
reaches a data limit.  A sender MUST NOT send multiple BLOCKED or STREAM_BLOCKED
frames for the same data limit, unless the original frame is determined to be
lost.  Another BLOCKED or STREAM_BLOCKED frame can be sent after the data limit
is increased.</t>

</section>
</section>
<section anchor="final-offset" title="Stream Final Offset">

<t>The final offset is the count of the number of octets that are transmitted on a
stream.  For a stream that is reset, the final offset is carried explicitly in
the RST_STREAM frame.  Otherwise, the final offset is the offset of the end of
the data carried in STREAM frame marked with a FIN flag.</t>

<t>An endpoint will know the final offset for a stream when it receives a STREAM
frame with a FIN flag or a RST_STREAM frame.  If there is reordering or loss, an
endpoint might receive a STREAM frame with a FIN flag prior to the stream
entering the “closed” state.</t>

<t>An endpoint MUST NOT send data on a stream at or beyond the final offset.</t>

<t>Once a final offset for a stream is known, it cannot change.  If a RST_STREAM or
STREAM frame causes the final offset to change for a stream, an endpoint SHOULD
respond with a QUIC_STREAM_DATA_AFTER_TERMINATION error (see
<xref target="error-handling"/>).  A receiver SHOULD treat receipt of data at or beyond the
final offset as a QUIC_STREAM_DATA_AFTER_TERMINATION error, even after a stream
is closed.  Generating these errors is not mandatory, but only because
requiring that an endpoint generate these errors also means that the endpoint
needs to maintain the final offset state for closed streams, which could mean a
significant state commitment.</t>

<t>Once the final offset is known, the receiving endpoint does not need to send any
additional MAX_STREAM_DATA frames for the stream.</t>

</section>
</section>
<section anchor="error-handling" title="Error Handling">

<t>An endpoint that detects an error SHOULD signal the existence of that error to
its peer.  Errors can affect an entire connection (see <xref target="connection-errors"/>),
or a single stream (see <xref target="stream-errors"/>).</t>

<t>The most appropriate error code (<xref target="error-codes"/>) SHOULD be included in the
frame that signals the error.  Where this specification identifies error
conditions, it also identifies the error code that is used.</t>

<t>Public Reset is not suitable for any error that can be signaled with a
CONNECTION_CLOSE or RST_STREAM frame.  Public Reset MUST NOT be sent by an
endpoint that has the state necessary to send a frame on the connection.</t>

<section anchor="connection-errors" title="Connection Errors">

<t>Errors that result in the connection being unusable, such as an obvious
violation of protocol semantics or corruption of state that affects an entire
connection, MUST be signaled using a CONNECTION_CLOSE frame
(<xref target="frame-connection-close"/>). An endpoint MAY close the connection in this
manner, even if the error only affects a single stream.</t>

<t>A CONNECTION_CLOSE frame could be sent in a packet that is lost.  An endpoint
SHOULD be prepared to retransmit a packet containing a CONNECTION_CLOSE frame if
it receives more packets on a terminated connection.  Limiting the number of
retransmissions and the time over which this final packet is sent limits the
effort expended on terminated connections.</t>

<t>An endpoint that chooses not to retransmit packets containing CONNECTION_CLOSE
risks a peer missing the first such packet.  The only mechanism available to an
endpoint that continues to receive data for a terminated connection is to send a
Public Reset packet.</t>

</section>
<section anchor="stream-errors" title="Stream Errors">

<t>If the error affects a single stream, but otherwise leaves the connection in a
recoverable state, the endpoint can send a RST_STREAM frame
(<xref target="frame-rst-stream"/>) with an appropriate error code to terminate just the
affected stream.</t>

<t>Stream 0 is critical to the functioning of the entire connection.  If stream 0
is closed with either a RST_STREAM or STREAM frame bearing the FIN flag, an
endpoint MUST generate a connection error of type QUIC_CLOSED_CRITICAL_STREAM.</t>

<t>Some application protocols make other streams critical to that protocol.  An
application protocol does not need to inform the transport that a stream is
critical; it can instead generate appropriate errors in response to being
notified that the critical stream is closed.</t>

<t>An endpoint MAY send a RST_STREAM frame in the same packet as a CONNECTION_CLOSE
frame.</t>

</section>
<section anchor="error-codes" title="Error Codes">

<t>Error codes are 32 bits long, with the first two bits indicating the source of
the error code:</t>

<t><list style="hanging">
  <t hangText='0x00000000-0x3FFFFFFF:'>
  Application-specific error codes.  Defined by each application-layer protocol.</t>
  <t hangText='0x40000000-0x7FFFFFFF:'>
  Reserved for host-local error codes.  These codes MUST NOT be sent to a peer,
but MAY be used in API return codes and logs.</t>
  <t hangText='0x80000000-0xBFFFFFFF:'>
  QUIC transport error codes, including packet protection errors.  Applicable to
all uses of QUIC.</t>
  <t hangText='0xC0000000-0xFFFFFFFF:'>
  Cryptographic error codes.  Defined by the cryptographic handshake protocol
in use.</t>
</list></t>

<t>This section lists the defined QUIC transport error codes that may be used in a
CONNECTION_CLOSE or RST_STREAM frame. Error codes share a common code space.
Some error codes apply only to either streams or the entire connection and have
no defined semantics in the other context.</t>

<t><list style="hanging">
  <t hangText='QUIC_INTERNAL_ERROR (0x80000001):'>
  Connection has reached an invalid state.</t>
  <t hangText='QUIC_STREAM_DATA_AFTER_TERMINATION (0x80000002):'>
  There were data frames after the a fin or reset.</t>
  <t hangText='QUIC_INVALID_PACKET_HEADER (0x80000003):'>
  Control frame is malformed.</t>
  <t hangText='QUIC_INVALID_FRAME_DATA (0x80000004):'>
  Frame data is malformed.</t>
  <t hangText='QUIC_MULTIPLE_TERMINATION_OFFSETS (0x80000005):'>
  Multiple final offset values were received on the same stream</t>
  <t hangText='QUIC_STREAM_CANCELLED (0x80000006):'>
  The stream was cancelled</t>
  <t hangText='QUIC_CLOSED_CRITICAL_STREAM (0x80000007):'>
  A stream that is critical to the protocol was closed.</t>
  <t hangText='QUIC_MISSING_PAYLOAD (0x80000030):'>
  The packet contained no payload.</t>
  <t hangText='QUIC_INVALID_STREAM_DATA (0x8000002E):'>
  STREAM frame data is malformed.</t>
  <t hangText='QUIC_UNENCRYPTED_STREAM_DATA (0x8000003D):'>
  Received STREAM frame data is not encrypted.</t>
  <t hangText='QUIC_MAYBE_CORRUPTED_MEMORY (0x80000059):'>
  Received a frame which is likely the result of memory corruption.</t>
  <t hangText='QUIC_INVALID_RST_STREAM_DATA (0x80000006):'>
  RST_STREAM frame data is malformed.</t>
  <t hangText='QUIC_INVALID_CONNECTION_CLOSE_DATA (0x80000007):'>
  CONNECTION_CLOSE frame data is malformed.</t>
  <t hangText='QUIC_INVALID_GOAWAY_DATA (0x80000008):'>
  GOAWAY frame data is malformed.</t>
  <t hangText='QUIC_INVALID_WINDOW_UPDATE_DATA (0x80000039):'>
  WINDOW_UPDATE frame data is malformed.</t>
  <t hangText='QUIC_INVALID_BLOCKED_DATA (0x8000003A):'>
  BLOCKED frame data is malformed.</t>
  <t hangText='QUIC_INVALID_PATH_CLOSE_DATA (0x8000004E):'>
  PATH_CLOSE frame data is malformed.</t>
  <t hangText='QUIC_INVALID_ACK_DATA (0x80000009):'>
  ACK frame data is malformed.</t>
  <t hangText='QUIC_INVALID_VERSION_NEGOTIATION_PACKET (0x8000000A):'>
  Version negotiation packet is malformed.</t>
  <t hangText='QUIC_INVALID_PUBLIC_RST_PACKET (0x8000000b):'>
  Public RST packet is malformed.</t>
  <t hangText='QUIC_DECRYPTION_FAILURE (0x8000000c):'>
  There was an error decrypting.</t>
  <t hangText='QUIC_ENCRYPTION_FAILURE (0x8000000d):'>
  There was an error encrypting.</t>
  <t hangText='QUIC_PACKET_TOO_LARGE (0x8000000e):'>
  The packet exceeded kMaxPacketSize.</t>
  <t hangText='QUIC_PEER_GOING_AWAY (0x80000010):'>
  The peer is going away. May be a client or server.</t>
  <t hangText='QUIC_INVALID_STREAM_ID (0x80000011):'>
  A stream ID was invalid.</t>
  <t hangText='QUIC_INVALID_PRIORITY (0x80000031):'>
  A priority was invalid.</t>
  <t hangText='QUIC_TOO_MANY_OPEN_STREAMS (0x80000012):'>
  Too many streams already open.</t>
  <t hangText='QUIC_TOO_MANY_AVAILABLE_STREAMS (0x8000004c):'>
  The peer created too many available streams.</t>
  <t hangText='QUIC_PUBLIC_RESET (0x80000013):'>
  Received public reset for this connection.</t>
  <t hangText='QUIC_INVALID_VERSION (0x80000014):'>
  Invalid protocol version.</t>
  <t hangText='QUIC_INVALID_HEADER_ID (0x80000016):'>
  The Header ID for a stream was too far from the previous.</t>
  <t hangText='QUIC_INVALID_NEGOTIATED_VALUE (0x80000017):'>
  Negotiable parameter received during handshake had invalid value.</t>
  <t hangText='QUIC_DECOMPRESSION_FAILURE (0x80000018):'>
  There was an error decompressing data.</t>
  <t hangText='QUIC_NETWORK_IDLE_TIMEOUT (0x80000019):'>
  The connection timed out due to no network activity.</t>
  <t hangText='QUIC_HANDSHAKE_TIMEOUT (0x80000043):'>
  The connection timed out waiting for the handshake to complete.</t>
  <t hangText='QUIC_ERROR_MIGRATING_ADDRESS (0x8000001a):'>
  There was an error encountered migrating addresses.</t>
  <t hangText='QUIC_ERROR_MIGRATING_PORT (0x80000056):'>
  There was an error encountered migrating port only.</t>
  <t hangText='QUIC_EMPTY_STREAM_FRAME_NO_FIN (0x80000032):'>
  We received a STREAM_FRAME with no data and no fin flag set.</t>
  <t hangText='QUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATA (0x8000003b):'>
  The peer received too much data, violating flow control.</t>
  <t hangText='QUIC_FLOW_CONTROL_SENT_TOO_MUCH_DATA (0x8000003f):'>
  The peer sent too much data, violating flow control.</t>
  <t hangText='QUIC_FLOW_CONTROL_INVALID_WINDOW (0x80000040):'>
  The peer received an invalid flow control window.</t>
  <t hangText='QUIC_CONNECTION_IP_POOLED (0x8000003e):'>
  The connection has been IP pooled into an existing connection.</t>
  <t hangText='QUIC_TOO_MANY_OUTSTANDING_SENT_PACKETS (0x80000044):'>
  The connection has too many outstanding sent packets.</t>
  <t hangText='QUIC_TOO_MANY_OUTSTANDING_RECEIVED_PACKETS (0x80000045):'>
  The connection has too many outstanding received packets.</t>
  <t hangText='QUIC_CONNECTION_CANCELLED (0x80000046):'>
  The QUIC connection has been cancelled.</t>
  <t hangText='QUIC_BAD_PACKET_LOSS_RATE (0x80000047):'>
  Disabled QUIC because of high packet loss rate.</t>
  <t hangText='QUIC_PUBLIC_RESETS_POST_HANDSHAKE (0x80000049):'>
  Disabled QUIC because of too many PUBLIC_RESETs post handshake.</t>
  <t hangText='QUIC_TIMEOUTS_WITH_OPEN_STREAMS (0x8000004a):'>
  Disabled QUIC because of too many timeouts with streams open.</t>
  <t hangText='QUIC_TOO_MANY_RTOS (0x80000055):'>
  QUIC timed out after too many RTOs.</t>
  <t hangText='QUIC_ENCRYPTION_LEVEL_INCORRECT (0x8000002c):'>
  A packet was received with the wrong encryption level (i.e. it should
have been encrypted but was not.)</t>
  <t hangText='QUIC_VERSION_NEGOTIATION_MISMATCH (0x80000037):'>
  This connection involved a version negotiation which appears to have been
tampered with.</t>
  <t hangText='QUIC_IP_ADDRESS_CHANGED (0x80000050):'>
  IP address changed causing connection close.</t>
  <t hangText='QUIC_ADDRESS_VALIDATION_FAILURE (0x80000051):'>
  Client address validation failed.</t>
  <t hangText='QUIC_TOO_MANY_FRAME_GAPS (0x8000005d):'>
  Stream frames arrived too discontiguously so that stream sequencer buffer
maintains too many gaps.</t>
  <t hangText='QUIC_TOO_MANY_SESSIONS_ON_SERVER (0x80000060):'>
  Connection closed because server hit max number of sessions allowed.</t>
</list></t>

</section>
</section>
<section anchor="security-and-privacy-considerations" title="Security and Privacy Considerations">

<section anchor="spoofed-ack-attack" title="Spoofed ACK Attack">

<t>An attacker receives an STK from the server and then releases the IP address on
which it received the STK.  The attacker may, in the future, spoof this same
address (which now presumably addresses a different endpoint), and initiate a
0-RTT connection with a server on the victim’s behalf.  The attacker then spoofs
ACK frames to the server which cause the server to potentially drown the victim
in data.</t>

<t>There are two possible mitigations to this attack.  The simplest one is that a
server can unilaterally create a gap in packet-number space.  In the non-attack
scenario, the client will send an ACK frame with the larger value for largest
acknowledged.  In the attack scenario, the attacker could acknowledge a packet
in the gap.  If the server sees an acknowledgment for a packet that was never
sent, the connection can be aborted.</t>

<t>The second mitigation is that the server can require that acknowledgments for
sent packets match the encryption level of the sent packet.  This mitigation is
useful if the connection has an ephemeral forward-secure key that is generated
and used for every new connection.  If a packet sent is protected with a
forward-secure key, then any acknowledgments that are received for them MUST
also be forward-secure protected.  Since the attacker will not have the forward
secure key, the attacker will not be able to generate forward-secure protected
packets with ACK frames.</t>

</section>
<section anchor="slowloris-attacks" title="Slowloris Attacks">

<t>The attacks commonly known as Slowloris <xref target="SLOWLORIS"/> try to keep many
connections to the target endpoint open and hold them open as long as possible.
These attacks can be executed against a QUIC endpoint by generating the minimum
amount of activity necessary to avoid being closed for inactivity.  This might
involve sending small amounts of data, gradually opening flow control windows in
order to control the sender rate, or manufacturing ACK frames that simulate a
high loss rate.</t>

<t>QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as
increasing the maximum number of clients the server will allow, limiting the
number of connections a single IP address is allowed to make, imposing
restrictions on the minimum transfer speed a connection is allowed to have, and
restricting the length of time an endpoint is allowed to stay connected.</t>

</section>
<section anchor="stream-fragmentation-and-reassembly-attacks" title="Stream Fragmentation and Reassembly Attacks">

<t>An adversarial endpoint might intentionally fragment the data on stream buffers
in order to cause disproportionate memory commitment.  An adversarial endpoint
could open a stream and send some STREAM frames containing arbitrary fragments
of the stream content.</t>

<t>The attack is mitigated if flow control windows correspond to available
memory.  However, some receivers will over-commit memory and advertise flow
control offsets in the aggregate that exceed actual available memory.  The
over-commitment strategy can lead to better performance when endpoints are well
behaved, but renders endpoints vulnerable to the stream fragmentation attack.</t>

<t>QUIC deployments SHOULD provide mitigations against the stream fragmentation
attack.  Mitigations could consist of avoiding over-committing memory, delaying
reassembly of STREAM frames, implementing heuristics based on the age and
duration of reassembly holes, or some combination.</t>

</section>
<section anchor="stream-commitment-attack" title="Stream Commitment Attack">

<t>An adversarial endpoint can open lots of streams, exhausting state on an
endpoint.  The adversarial endpoint could repeat the process on a large number
of connections, in a manner similar to SYN flooding attacks in TCP.</t>

<t>Normally, clients will open streams sequentially, as explained in <xref target="stream-id"/>.
However, when several streams are initiated at short intervals, transmission
error may cause STREAM DATA frames opening streams to be received out of
sequence.  A receiver is obligated to open intervening streams if a
higher-numbered stream ID is received.  Thus, on a new connection, opening
stream 2000001 opens 1 million streams, as required by the specification.</t>

<t>The number of active streams is limited by the concurrent stream limit transport
parameter, as explained in <xref target="stream-concurrency"/>.  If chosen judisciously, this
limit mitigates the effect of the stream commitment attack.  However, setting
the limit too low could affect performance when applications expect to open
large number of streams.</t>

</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<section anchor="iana-transport-parameters" title="QUIC Transport Parameter Registry">

<t>IANA [SHALL add/has added] a registry for “QUIC Transport Parameters” under a
“QUIC Protocol” heading.</t>

<t>The “QUIC Transport Parameters” registry governs a 16-bit space.  This space is
split into two spaces that are governed by different policies.  Values with the
first byte in the range 0x00 to 0xfe (in hexadecimal) are assigned via the
Specification Required policy <xref target="RFC5226"/>.  Values with the first byte 0xff are
reserved for Private Use <xref target="RFC5226"/>.</t>

<t>Registrations MUST include the following fields:</t>

<t><list style="hanging">
  <t hangText='Value:'>
  The numeric value of the assignment (registrations will be between 0x0000 and
0xfeff).</t>
  <t hangText='Parameter Name:'>
  A short mnemonic for the parameter.</t>
  <t hangText='Specification:'>
  A reference to a publicly available specification for the value.</t>
</list></t>

<t>The nominated expert(s) verify that a specification exists and is readily
accessible.  The expert(s) are encouraged to be biased towards approving
registrations unless they are abusive, frivolous, or actively harmful (not
merely aesthetically displeasing, or architecturally dubious).</t>

<t>The initial contents of this registry are shown in
<xref target="iana-tp-table"/>.</t>

<texttable title="Initial QUIC Transport Parameters Entries" anchor="iana-tp-table">
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Parameter Name</ttcol>
      <ttcol align='left'>Specification</ttcol>
      <c>0x0000</c>
      <c>initial_max_stream_data</c>
      <c><xref target="transport-parameter-definitions"/></c>
      <c>0x0001</c>
      <c>initial_max_data</c>
      <c><xref target="transport-parameter-definitions"/></c>
      <c>0x0002</c>
      <c>initial_max_stream_id</c>
      <c><xref target="transport-parameter-definitions"/></c>
      <c>0x0003</c>
      <c>idle_timeout</c>
      <c><xref target="transport-parameter-definitions"/></c>
      <c>0x0004</c>
      <c>truncate_connection_id</c>
      <c><xref target="transport-parameter-definitions"/></c>
      <c>0x0005</c>
      <c>max_packet_size</c>
      <c><xref target="transport-parameter-definitions"/></c>
</texttable>

</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

<reference anchor="QUIC-RECOVERY" >
  <front>
    <title>QUIC Loss Detection and Congestion Control</title>
    <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
      <organization>Google</organization>
    </author>
    <author initials="I." surname="Swett" fullname="Ian Swett" role="editor">
      <organization>Google</organization>
    </author>
    <date year="2017" month="July"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-quic-recovery"/>
</reference>
<reference anchor="QUIC-TLS" >
  <front>
    <title>Using Transport Layer Security (TLS) to Secure QUIC</title>
    <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
      <organization>Mozilla</organization>
    </author>
    <author initials="S." surname="Turner" fullname="Sean Turner" role="editor">
      <organization>sn3rd</organization>
    </author>
    <date year="2017" month="July"/>
  </front>
  <seriesInfo name="Internet-Draft" value="draft-ietf-quic-tls"/>
</reference>




<reference  anchor="RFC2119" target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-tls-tls13">
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.3</title>

<author initials='E' surname='Rescorla' fullname='Eric Rescorla'>
    <organization />
</author>

<date month='July' day='3' year='2017' />

<abstract><t>This document specifies version 1.3 of the Transport Layer Security (TLS) protocol.  TLS allows client/server applications to communicate over the Internet in a way that is designed to prevent eavesdropping, tampering, and message forgery.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-tls-tls13-21' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-tls-tls13-21.txt' />
</reference>



<reference  anchor="RFC3629" target='http://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor="RFC4821" target='http://www.rfc-editor.org/info/rfc4821'>
<front>
<title>Packetization Layer Path MTU Discovery</title>
<author initials='M.' surname='Mathis' fullname='M. Mathis'><organization /></author>
<author initials='J.' surname='Heffner' fullname='J. Heffner'><organization /></author>
<date year='2007' month='March' />
<abstract><t>This document describes a robust method for Path MTU Discovery (PMTUD) that relies on TCP or some other Packetization Layer to probe an Internet path with progressively larger packets.  This method is described as an extension to RFC 1191 and RFC 1981, which specify ICMP-based Path MTU Discovery for IP versions 4 and 6, respectively.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4821'/>
<seriesInfo name='DOI' value='10.17487/RFC4821'/>
</reference>



<reference  anchor="RFC1191" target='http://www.rfc-editor.org/info/rfc1191'>
<front>
<title>Path MTU discovery</title>
<author initials='J.C.' surname='Mogul' fullname='J.C. Mogul'><organization /></author>
<author initials='S.E.' surname='Deering' fullname='S.E. Deering'><organization /></author>
<date year='1990' month='November' />
<abstract><t>This memo describes a technique for dynamically discovering the maximum transmission unit (MTU) of an arbitrary internet path.  It specifies a small change to the way routers generate one type of ICMP message.  For a path that passes through a router that has not been so changed, this technique might not discover the correct Path MTU, but it will always choose a Path MTU as accurate as, and in many cases more accurate than, the Path MTU that would be chosen by current practice.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='1191'/>
<seriesInfo name='DOI' value='10.17487/RFC1191'/>
</reference>



<reference  anchor="RFC1981" target='http://www.rfc-editor.org/info/rfc1981'>
<front>
<title>Path MTU Discovery for IP version 6</title>
<author initials='J.' surname='McCann' fullname='J. McCann'><organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
<author initials='J.' surname='Mogul' fullname='J. Mogul'><organization /></author>
<date year='1996' month='August' />
<abstract><t>This document describes Path MTU Discovery for IP version 6.  It is largely derived from RFC 1191, which describes Path MTU Discovery for IP version 4.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='1981'/>
<seriesInfo name='DOI' value='10.17487/RFC1981'/>
</reference>



<reference  anchor="RFC5226" target='http://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>




    </references>

    <references title='Informative References'>

<reference anchor="EARLY-DESIGN" target="https://goo.gl/dMVtFi">
  <front>
    <title>QUIC: Multiplexed Transport Over UDP</title>
    <author initials="J." surname="Roskind">
      <organization></organization>
    </author>
    <date year="2013" month="December" day="02"/>
  </front>
</reference>
<reference anchor="SLOWLORIS" target="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">
  <front>
    <title>Welcome to Slowloris...</title>
    <author initials="R." surname="RSnake Hansen">
      <organization></organization>
    </author>
    <date year="2009" month="June"/>
  </front>
</reference>




<reference  anchor="RFC2360" target='http://www.rfc-editor.org/info/rfc2360'>
<front>
<title>Guide for Internet Standards Writers</title>
<author initials='G.' surname='Scott' fullname='G. Scott'><organization /></author>
<date year='1998' month='June' />
<abstract><t>This document is a guide for Internet standard writers.  It defines those characteristics that make standards coherent, unambiguous, and easy to interpret.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='22'/>
<seriesInfo name='RFC' value='2360'/>
<seriesInfo name='DOI' value='10.17487/RFC2360'/>
</reference>



<reference  anchor="RFC6824" target='http://www.rfc-editor.org/info/rfc6824'>
<front>
<title>TCP Extensions for Multipath Operation with Multiple Addresses</title>
<author initials='A.' surname='Ford' fullname='A. Ford'><organization /></author>
<author initials='C.' surname='Raiciu' fullname='C. Raiciu'><organization /></author>
<author initials='M.' surname='Handley' fullname='M. Handley'><organization /></author>
<author initials='O.' surname='Bonaventure' fullname='O. Bonaventure'><organization /></author>
<date year='2013' month='January' />
<abstract><t>TCP/IP communication is currently restricted to a single path per connection, yet multiple paths often exist between peers.  The simultaneous use of these multiple paths for a TCP/IP session would improve resource usage within the network and, thus, improve user experience through higher throughput and improved resilience to network failure.</t><t>Multipath TCP provides the ability to simultaneously use multiple paths between peers.  This document presents a set of extensions to traditional TCP to support multipath operation.  The protocol offers the same type of service to applications as TCP (i.e., reliable bytestream), and it provides the components necessary to establish and use multiple TCP flows across potentially disjoint paths.  This  document defines an Experimental Protocol for the Internet community.</t></abstract>
</front>
<seriesInfo name='RFC' value='6824'/>
<seriesInfo name='DOI' value='10.17487/RFC6824'/>
</reference>



<reference  anchor="RFC4086" target='http://www.rfc-editor.org/info/rfc4086'>
<front>
<title>Randomness Requirements for Security</title>
<author initials='D.' surname='Eastlake 3rd' fullname='D. Eastlake 3rd'><organization /></author>
<author initials='J.' surname='Schiller' fullname='J. Schiller'><organization /></author>
<author initials='S.' surname='Crocker' fullname='S. Crocker'><organization /></author>
<date year='2005' month='June' />
<abstract><t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t><t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='106'/>
<seriesInfo name='RFC' value='4086'/>
<seriesInfo name='DOI' value='10.17487/RFC4086'/>
</reference>



<reference  anchor="RFC7301" target='http://www.rfc-editor.org/info/rfc7301'>
<front>
<title>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</title>
<author initials='S.' surname='Friedl' fullname='S. Friedl'><organization /></author>
<author initials='A.' surname='Popov' fullname='A. Popov'><organization /></author>
<author initials='A.' surname='Langley' fullname='A. Langley'><organization /></author>
<author initials='E.' surname='Stephan' fullname='E. Stephan'><organization /></author>
<date year='2014' month='July' />
<abstract><t>This document describes a Transport Layer Security (TLS) extension for application-layer protocol negotiation within the TLS handshake. For instances in which multiple application protocols are supported on the same TCP or UDP port, this extension allows the application layer to negotiate which protocol will be used within the TLS connection.</t></abstract>
</front>
<seriesInfo name='RFC' value='7301'/>
<seriesInfo name='DOI' value='10.17487/RFC7301'/>
</reference>

<reference anchor="SST" >
  <front>
    <title>Structured streams</title>
    <author initials="B." surname="Ford" fullname="Bryan Ford">
      <organization></organization>
    </author>
    <date year="2007" month="October"/>
  </front>
  <seriesInfo name="ACM SIGCOMM Computer Communication Review" value="Vol. 37, pp. 361"/>
  <seriesInfo name="DOI" value="10.1145/1282427.1282421"/>
</reference>



<reference  anchor="RFC7540" target='http://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>




    </references>


<section anchor="contributors" title="Contributors">

<t>The original authors of this specification were Ryan Hamilton, Jana Iyengar, Ian
Swett, and Alyssa Wilk.</t>

<t>The original design and rationale behind this protocol draw significantly from
work by Jim Roskind <xref target="EARLY-DESIGN"/>. In alphabetical order, the contributors to
the pre-IETF QUIC project at Google are: Britt Cyr, Jeremy Dorfman, Ryan
Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley,
Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti,
Victor Vasiliev, Antonio Vicente, Patrik Westin, Alyssa Wilk, Dale Worley, Fan
Yang, Dan Zhang, Daniel Ziegler.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Special thanks are due to the following for helping shape pre-IETF QUIC and its
deployment: Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch,
Siddharth Vijayakrishnan, and Assar Westerlund.</t>

<t>This document has benefited immensely from various private discussions and
public ones on the quic@ietf.org and proto-quic@chromium.org mailing lists. Our
thanks to all.</t>

</section>
<section anchor="change-log" title="Change Log">

<t><list style='empty'>
  <t><spanx style="strong">RFC Editor’s Note:</spanx> Please remove this section prior to publication of a
final version of this document.</t>
</list></t>

<t>Issue and pull request numbers are listed with a leading octothorp.</t>

<section anchor="since-draft-ietf-quic-transport-03" title="Since draft-ietf-quic-transport-03">

<t><list style="symbols">
  <t>Change STREAM and RST_STREAM layout</t>
  <t>Add MAX_STREAM_ID settings</t>
</list></t>

</section>
<section anchor="since-draft-ietf-quic-transport-02" title="Since draft-ietf-quic-transport-02">

<t><list style="symbols">
  <t>The size of the initial packet payload has a fixed minimum (#267, #472)</t>
  <t>Define when Version Negotiation packets are ignored (#284, #294, #241, #143,
#474)</t>
  <t>The 64-bit FNV-1a algorithm is used for integrity protection of unprotected
packets (#167, #480, #481, #517)</t>
  <t>Rework initial packet types to change how the connection ID is chosen (#482,
#442, #493)</t>
  <t>No timestamps are forbidden in unprotected packets (#542, #429)</t>
  <t>Cryptographic handshake is now on stream 0 (#456)</t>
  <t>Remove congestion control exemption for cryptographic handshake (#248, #476)</t>
  <t>Version 1 of QUIC uses TLS; a new version is needed to use a different
handshake protocol (#516)</t>
  <t>STREAM frames have a reduced number of offset lengths (#543, #430)</t>
  <t>Split some frames into separate connection- and stream- level frames
(#443)
  <list style="symbols">
      <t>WINDOW_UPDATE split into MAX_DATA and MAX_STREAM_DATA (#450)</t>
      <t>BLOCKED split to match WINDOW_UPDATE split (#454)</t>
      <t>Define STREAM_ID_NEEDED frame (#455)</t>
    </list></t>
  <t>A NEW_CONNECTION_ID frame supports connection migration without linkability
(#232, #491, #496)</t>
  <t>Transport parameters for 0-RTT are retained from a previous connection (#512)
  <list style="symbols">
      <t>A client in 0-RTT no longer required to reset excess streams (#425, #479)</t>
    </list></t>
  <t>Expanded security considerations (#440, #444, #445, #448)</t>
</list></t>

</section>
<section anchor="since-draft-ietf-quic-transport-01" title="Since draft-ietf-quic-transport-01">

<t><list style="symbols">
  <t>Defined short and long packet headers (#40, #148, #361)</t>
  <t>Defined a versioning scheme and stable fields (#51, #361)</t>
  <t>Define reserved version values for “greasing” negotiation (#112, #278)</t>
  <t>The initial packet number is randomized (#35, #283)</t>
  <t>Narrow the packet number encoding range requirement (#67, #286, #299, #323,
#356)</t>
  <t>Defined client address validation (#52, #118, #120, #275)</t>
  <t>Define transport parameters as a TLS extension (#49, #122)</t>
  <t>SCUP and COPT parameters are no longer valid (#116, #117)</t>
  <t>Transport parameters for 0-RTT are either remembered from before, or assume
default values (#126)</t>
  <t>The server chooses connection IDs in its final flight (#119, #349, #361)</t>
  <t>The server echoes the Connection ID and packet number fields when sending a
Version Negotiation packet (#133, #295, #244)</t>
  <t>Defined a minimum packet size for the initial handshake packet from the client
(#69, #136, #139, #164)</t>
  <t>Path MTU Discovery (#64, #106)</t>
  <t>The initial handshake packet from the client needs to fit in a single packet
(#338)</t>
  <t>Forbid acknowledgment of packets containing only ACK and PADDING (#291)</t>
  <t>Require that frames are processed when packets are acknowledged (#381, #341)</t>
  <t>Removed the STOP_WAITING frame (#66)</t>
  <t>Don’t require retransmission of old timestamps for lost ACK frames (#308)</t>
  <t>Clarified that frames are not retransmitted, but the information in them can
be (#157, #298)</t>
  <t>Error handling definitions (#335)</t>
  <t>Split error codes into four sections (#74)</t>
  <t>Forbid the use of Public Reset where CONNECTION_CLOSE is possible (#289)</t>
  <t>Define packet protection rules (#336)</t>
  <t>Require that stream be entirely delivered or reset, including acknowledgment
of all STREAM frames or the RST_STREAM, before it closes (#381)</t>
  <t>Remove stream reservation from state machine (#174, #280)</t>
  <t>Only stream 1 does not contribute to connection-level flow control (#204)</t>
  <t>Stream 1 counts towards the maximum concurrent stream limit (#201, #282)</t>
  <t>Remove connection-level flow control exclusion for some streams (except 1)
(#246)</t>
  <t>RST_STREAM affects connection-level flow control (#162, #163)</t>
  <t>Flow control accounting uses the maximum data offset on each stream, rather
than bytes received (#378)</t>
  <t>Moved length-determining fields to the start of STREAM and ACK (#168, #277)</t>
  <t>Added the ability to pad between frames (#158, #276)</t>
  <t>Remove error code and reason phrase from GOAWAY (#352, #355)</t>
  <t>GOAWAY includes a final stream number for both directions (#347)</t>
  <t>Error codes for RST_STREAM and CONNECTION_CLOSE are now at a consistent offset
(#249)</t>
  <t>Defined priority as the responsibility of the application protocol (#104,
#303)</t>
</list></t>

</section>
<section anchor="since-draft-ietf-quic-transport-00" title="Since draft-ietf-quic-transport-00">

<t><list style="symbols">
  <t>Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag</t>
  <t>Defined versioning</t>
  <t>Reworked description of packet and frame layout</t>
  <t>Error code space is divided into regions for each component</t>
  <t>Use big endian for all numeric values</t>
</list></t>

</section>
<section anchor="since-draft-hamilton-quic-transport-protocol-01" title="Since draft-hamilton-quic-transport-protocol-01">

<t><list style="symbols">
  <t>Adopted as base for draft-ietf-quic-tls</t>
  <t>Updated authors/editors list</t>
  <t>Added IANA Considerations section</t>
  <t>Moved Contributors and Acknowledgments to appendices</t>
</list></t>

</section>
</section>


  </back>

<!-- ##markdown-source:
H4sIAK0AX1kAA+y9aX/cRnYv/L4+BSK/GHLSTbGpxbKc5dIiNeYdbRFpzzM/
Z6IBu9Ekou5GB0CTYmTfz/6cvU4BaFLOWHN9J1EWSyRQqOXU2c//jMfj0Jbt
onia3fuX706ePc0Os++O3oy/yZtilr3cLNpyvSg+wN/z1Sw7LaabusjO6nzV
rKu6vRfy8/O6uHqa4bvx59mbumqrabUIs2q6ypcw+qzO5+24LNr5+D825XTc
6rPjRd4WTRtm8J+n2cH+5Mvx/pdhCv+6qOqbp1nTzkK5rp9mbb1p2oP9/a/2
D0JeF/nT+L1wXdXvL+pqs+aZhNC0MN93+aJawaA3RRPW5dPsB5jTKGvghbqY
N/C3myX/BWa5zNfrcnXxpxDyTXtZ1U9Dlo3h/7KsXDVPs/+9l53cFKuLvKaf
8Zr+d77Kkx9X9cXT7HdVdbEo6N/FMi8XT7N/r8v/dUE/3ZtWS/pNXeGWF7Oy
rer0Sy/3srPLatlUK/ell3ndlqvkF/Stl9V/lotF7j+2pEf3Wn70f13gT4c/
G1ZVvczb8qp4GuC3uHHjt8fPXn9//PaPT+lxTxnZi6ppsqOiLaZtWa2IHp5V
qws4O/wn/LWF0e/Re+lZ4k+aoi6LplzNKx45y05WbVGvinZ8hJTRJ5C6mFZX
RX1Dj8czwT9j+e/w2dxyPkNnNHAaA9842ctOr4u27XzhJF91fn7n8LrTZy9O
003+Drbnwt2hF/lNUfOVK9ubbAde2M3aSi8hDvLL7Xa7aO7e6A5p3kqegyT6
aXt9Cp/ZwGS7x3lawG53fkOfaFYP6tmW3cZN8FR+fPj2xR/HR8enJ7971Sfy
pwnLi2fxGigR+eK9oU0yKnxbNe/L1Sw9lAfjycEYWBZ9Kq8vCtj9e5dtu26e
3r8PXGHvYnF/9vL79nl5D+d3+uL1H168fnvSIY4/FAu4wwWd/6K6XlR12ezt
7d0yn7cwn9NV/r7IvoVVFKtkVvtfjfcf+ynxuzav6+J8L6+nl7Bre7DF+O/7
sJZH+w/g/x49fPLgyX18FJ68zPem74u6occandp9WEsYj8dZft4Ap5+2IZxd
lg0y2s2yWLXZrJiXq6LJ2ssim1ZAztWc/k6cxmRDthY5spdlyfthVjTTujyH
EabVaiUsCVhRfr4om0t8ZJStc5hZm/H5j7KlnixeM+RedbEo8/NyAbdrLxxO
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
tSqUBls1SpQ8/ZyvzCusAccxsXQbp3xOxJlzzmyKAr+2ogzGqDWEFJA8671J
RilZ9Y2FMdisCRaxw5h8MiEs0lXenIJ1ilyFlmZp54gTSssFv4gki/j7SWNQ
LV+5CtRwFo3d1Hui20lTD4JDIQYgzWdlBYvEcpnzn7W4u8SSJGWPODDDF759
G4F5cXI2HIz+/jtdMF7pc57f0ePksD4mpBZ474Kg5DIPnKIzG/OK8o8CHaZK
IGIErd3A+CLkX2G6RBEmiaNZo1Dr1UqXyEi/MfNmeZsEjiK11GPklYD0uTpq
oK0v5mbY25FHuipRhCzFgXPguBOjp++kYPVKueZS6nO0mFbo+EqM6UB/twgI
/IrQGiW+ZfMlJr5IAXP3LDDkjvL68QkiNb6pv6fjHDmJ+Jg3OPG8xFe/Q9h7
2QaDjCWu8sfCJfk4hnbhC/ePFZ5n0ic6jBWSbycRr7sdIkO6uHe/MIVEs7o6
mK1V4icRCryoCvm2PLKy+xyKndBbk5P2GqNzXKN4P7mQt7Unk5zl8xtMKJkI
zb1DLsRNgNW30g7WgP5VdhOICZm9OQPd4hYVDbuTPWHBgcOJzNoN4DjW350z
hnVGZWP5dTHcvNGhizaJ2xWYNFhbAIUU4RzwrmA7mKGm8SED3xJ6rW0YCT+K
fHd9Ejs9ysSi0CAyc3i26qqAzajCuOvEyo5RQxRK5jK74XUOTw0X4mi9RURh
ynBwutCaFcdTcyVzeYyK8pbEOARHbfH0dTEom9Lycn3JcyM7FyUgu7lBcnmF
QgopPN5UWLfgN7aRwNQS1yHtn3CfrkjYIc8WY2oWC+KvD3yulLEQEv0zinbP
ZgnqkUSWgFZfJXRa4XNflrO5wL9iwudJfCRZzfsxiaHieFOriSmP79y3rMpI
XdQsmVEGE9IrLM2C015vCdtOJef4rtulaZKPd0L+JnmXcxCWNSEWLPGQd4wy
XJPxMqSHuVbhiZJqInRWYCxXQjzarGZh++ctnbbLi9tKd2ZWLhw7DPSSf51m
UqdCau/NPfhMTYPWRoWv6i4X/Q+255pNJKXtEqkcU2kS9IaY8hAb65N1R58Q
/1ZybW59fwvK3qVqYxW+dKtQEYIvj6/gFOqez5jsGtOFMiWOjavaJXYn6VjX
+PcslAGkMveWe5otuHo4ScAKFHwkhHSo1YQdzwiuYSknByPi65J32GUH+4Is
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
mrjSkhIjkE8GZvZ/Acag8HIxAgA=

-->

</rfc>

